# 设计模式理论概念

#### 1. 适配器模式

将**类的接口转换成==客户==需要的另一个接口**，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作



#### 2. 组合模式

描述了如何构造一个类层次结构，这一结构由两种类型的对象所对应的类构成，其中的组合对象使得用户可以组合基元对象以及其它的组合对象，从而形成任意复杂的结构。

将对象组合成树形结构以表示**“整体——部分”**的层次结构，使得用户对单个对象组合和组合对象的使用具有一致性



#### 3. 装饰器模式

意图是**动态地给一个对象添加一些额外职责**。在需要给某个对象而不是整个类添加一些功能时使用。这种模式对增加功能比生成子类更加灵活



#### 4. 桥接模式

桥接模式**将对象的抽象和其实现分离**，从而可以独立的改变他们，抽象类定义该抽象的接口，而具体的子类则用不同方式加以实现。



##### 适配器模式和桥接模式相同的特征：

都给另一个对象提供了一定程度上的间接性，都涉及到自身以外的一个接口像这个对象转发请求。



#### 5. 外观模式

描述了如何用单个对象表示整个**子系统**，为子系统中的一组接口提供一个一致的界。适用于需要为一个复杂子系统提供一个简单接口的情况。 



#### 6. 单例模式

保证一个类产生唯一的一个实例



#### 7. 命令模式

将一个请求封装为一个对象，从而使使用者可以采用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作



#### 8. 观察者模式

表示一个作用于某对象中的结构元素的操作，是使用者可以在不改变各元素的类的前提下定义作用于这些元素的新操作

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新



#### 9. 状态模式

是使得一个对象在其内部状态改变时通过调用另一个类中的方法改变其行为，使这个对象看起来如共同修改了它的类



#### 10. 责任链模式

是多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。适用于有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定的情况。



#### 11. 抽象工厂

提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类



#### 12. 原型模式

原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象



#### 13. 工厂方法

定义一个用于创建对象的接口，**让子类决定哪一个类实例化**，使一个类的实例化延迟到其子类。



#### 14. 生成器模式

将一个复杂的对象构建与它的表示分离，使得同样的构建过程可以创建不同的表示。适用于当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时：当构造过程必须允许被构造的对象有不同的表示时。



#### 15. 策略模式

定义一系列算法，把他们一个个封装起来，并且是它们相互替换。这一模式使得算法可以独立于它的客户而变化。



#### 16. 迭代器模式

提供一种方法来顺序访问一个聚合对象中的各个元素，而不暴露该对象的内部表示



#### 17. 享元模式

运用共享技术有效地支持大量细粒度的对象。适用于：一个应用程序使用了大量的对象；完全由于使用大量的对象，造成很大的存储开销；对象的大多数状态都可变为外部状态；如果删除对象的外部状态，那么可以用相对较少的共享对象的取代很多组对象：应用程序不依赖于对象标识。



#### 18. 中介者模式

用一个终结对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互。

适用于一组对象定义良好但是复杂的方式进行通信，产生相互依赖关系结构混乱且难以理解；一个对象引用其他很多对象的并且直接与这些对象通信，导致很难服用该对象；想定制一个分布在多个类中的行为，而又不想生成太多的子类。欲使一个后端数据模型能被多个前端用户界面接连，采用中介者模式最合适。



#### 19. 访问者模式

使用一个访问者类，他改变了元素的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。





































































