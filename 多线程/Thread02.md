# Volatile 关键字

## volatile 的定义

> 关键字 volatile 可以用来修饰字段（成员变量），就是告知程序员任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性

而关键字 synchronized 可以修改方法或者以同步块的形式来进行使用，它主要确保多个线程在同一时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。

## 实现原理

 volatile 变量修饰的共享变量进行写操作的时候都出第二行汇编代码，Lock 前缀的指令在多核处理器下会引发两件事情

1. **将当前处理器缓存行的数据写回到系统内存**
2. **这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效**

**问题1：何时将数据写到内存？**

为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完不知何时会写到内存

如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存

**问题2：写到内存后其他线程的缓存数据还是旧的，如何解决？**

解决策略：

1. 在多处理器下，**实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了**，当处理器发现自己缓存行对应的内存地址被修改，就会**将当前处理器的缓存行设置成无效状态**
2. 当处理器对这个数据进行修改的时候，会 **重新从系统内存把数据读到处理器缓存里**





## volatile 变量的特性

volatile 可以保证可见性，但不保证原子性

- 当写一个 volatile 变量时，JMM 会把该线程本地内存中的变量强制刷新到主内存中去
- 这个写操作会导致其他线程中的 volatile 变量缓存无效

## volatile 禁止指令重排规则

使用 volatile 关键字修饰共享变量可以禁止这种重排序。若用 volatile 修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序，volatile 禁止指令重排序也有一些规则

**volatile 中会增加一道内存屏障，这个内存屏障可以保证在这个屏障中的指令顺序**



# synchronized

## 什么是synchronized？

> `synchronized` 关键字解决的是多个线程之间访问资源的同步性，`synchronized` 关键字可以保证被它修改的方法或者代码块在任意时刻只能有一个线程执行

## synchronized 的三种应用方式

- 修饰实例对象，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
- 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
- 修改代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁

**双重校验锁实现对象单例（线程安全）**

```java
public class Singleton {
    private volatile static Singleton uniqueInstance;
    
    private Singleton() {
        
    }
    
    public static Singleton getUniqueInstance() {
        // 先判断对象是否已经实例过，没有实例化才进入加锁代码
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
    	return uniqueInstance;
    } 
}
```

## 构造方法可以使用 synchronized 关键字修饰么？

**构造方法不能使用 synchronized 关键字修饰**

构造方法本身就属于线程安全的，不存在同步的构造方法一说

# synchronized 锁的到底是什么？

首先需要明确的一点是：**Java多线程的锁都是基于对象的**，我们常听到的 **类锁** 其实也是对象锁。

## Synchronized 关键字

使用 `synchronized` 通常有以下三种形式：

```java
// 关键字在实例方法上，锁为当前实例
public synchronized void instanceLock() {
    // code
}

// 关键字在静态方法上，锁为当前 class 对象
public static synchronized void classLock(){
    // code
}

// 关键字在代码块上，锁为括号里面的对象
public void blockLock() {
    Object o = new Object();
    synchronized(o) {
        // code
    }
}
```

临界区：莫一块代码区域，同一时刻只能由一个线程执行

四种锁的状态，它们级别由低到高依次是：

1. 无锁状态
2. 偏向锁状态
3. 轻量级锁状态
4. 重量级锁状态

## 偏向锁

锁不仅不存在多线竞争，而且总是由同一线程多次获得，于是引入了偏向锁，偏向锁再无资源竞争的情况下消除了同步语句，连 CAS 操作都做不了，提高了程序的运行性能

**实现原理**

一个线程在第一次进入同步块时，会在对象头和栈帧中记录里存储锁的偏向的线程 ID。当下次该线程进入这个同步块时，会去检查锁的 Mark Word 里面是不是放的自己的线程ID

如果是，表明该线程已经获得锁，以后该线程进入和退出同步块时不需要花费 CAS 操作来加锁和解锁；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用 CAS 来替换Mark Word里面线程ID为新线程的ID，这个时候要分两种情况

- 成功，表示之前的线程不存在了，Mark Word 里面的线程 ID 为新线程的ID，所不会升级，仍然为偏向锁
- 失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为 0，并设置锁标志位为 00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。

**撤销偏向锁**

偏向锁使用了一种 **等待竞争出现才会释放的机制** 



## 轻量级锁

多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞，针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒

**轻量级锁的加锁**

如果一个线程获得锁的时候发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 里面

然后线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示 Mark Word 已经被替换成了其他线程的锁记录，说明在与其他线程竞争锁，当前线程就尝试使用自旋来获取锁

自旋指定次数，自旋次数之后还没有拿到锁就进入阻塞状态

自旋也不是一直进行下去的，如果到一定程度，依然没有拿到锁，称为自旋失败，这个线程会阻塞。同时这个锁就会**升级成重量级锁**



## 重量级锁

重量级锁依赖于操作系统的互斥量实现的，而操作系统中线程间的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU

当调用一个锁对象的`wait`或`notify`方法时，**如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁**。



## 锁的升级流程

每一个线程在准备获取共享资源是：第一步，检查 MarkWord 里面是不是放自己的 Threadld，如果是表示当前线程是处于 “偏向锁”

第二步，如果 MarkWord 不是自己的 Threadld ，锁升级，这时候，用 CAS 来执行切换，新的线程根据 MarkWord 里面现有的 Threadld，通知之前线程暂停，之前线程将 MarkWord 内容置为空。

第三步，两个线程都把锁对象的 hashCode 复制到新建的用于存储锁的记录空间，接着开始通过 CAS 操作，把锁对象的 markWord 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord。

第四步，第三步中成功执行 CAS 的获得资源，失败则进入自旋

第五步，自旋的线程在自旋过程中，成功获得资源，则整个状态依然处于轻量级锁的状态，如果自旋失败

第六步，进入重量级锁，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己



# Java 实现 CAS 原理

`CAS` 是乐观锁，线程执行的时候不会加锁，假设没有冲突去完成某项操作，如果因为冲突失败了就重试，最后直到成功为止	

**悲观锁概念：**对于悲观锁来说，他总是任务每次访问共享资源是发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程正在执行

**乐观锁概念：**又称为“无锁”，总是假设共享资源的访问没有冲突，线程可以不停的执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全性

## CAS 概念

CAS 全称：比较并交换（Compare And Swap）。在 CAS 中，有这样三个值

- V：要变更的变量
- E：预期值（expected）
- N：新值（new）

比较并交换的过程如下：

判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做

**当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作**

## CAS 实现原子操作的三大问题

### ABA 问题

即：一个值原来是A，变成了B，又变回了A。这个时候使用 CAS 是检查不出变化的，但实际上却被更新了两次。

ABA 问题的解决思路是在变量前面追加上 **版本号或时间戳**

### 循环时间长开销大

CAS 多余自选结合，如果CAS 长时间不成功，会占用大量的 CPU 资源。

解决思路是让 JVM 支持处理器提供的 **pause 指令**

pause 指令能让自旋失败时 cpu 睡眠一小段时间再继续自旋，从而使得读操作的频率低很多，为解决内存顺序冲突而导致的 CPU 流水线重排的代价也会小很多

### 只能保证一个共享变量的原子操作

1、把多个变量房贷一个对象里面进行 CAS 操作

2、使用锁。锁内的临界区代码可以保证只有当前线程能操作



# Java并发 AQS 

AQS：抽象队列同步器

**AQS 有什么用？**

AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效的构造出应用广泛的 同步器

## AQS 的数据结构

AQS 内部使用了一个 volatile 的变量 state 来作为资源的标识，同时定义了几个获取和改变 state 的protedted 方法，子类可以覆盖这些方法来实现自己的逻辑。

```java
getState()
setState()
compareAndSetState()
```

AQS 本身实现的是一些排队和阻塞的机制，比如具体线程等待队列的维护。它内部使用了一个先进先出的双端队列，并使用了两个指针 head 和 tail 用于标识队列的头部和尾部

![image-20220926111354117](https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220926111354117.png)

## 共享资源模式

- 独占模式：资源是独占的，一次只能一个线程获取。
- 共享模式：同时可以被多个线程获取，具体的资源个数可以通过参数指定



# 乐观锁 VS 悲观锁

对于同一个数据据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此再获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized 关键字 和 Lock 的实现类都是悲观锁

而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作

乐观锁在Java中是通过无锁编程来实现，最常采用的是 CAS 算法，Java 原子类中的递增操作就通过 CAS 自旋实现的



根据上面的概念描述我们可以发现：

- 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确
- 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升



悲观锁基本都是在显示的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？它主要实现方式 “CAS” 的技术



# 自旋锁 VS 适应性自旋锁

为了让当前线程“稍等一下”，我们需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁

自旋锁本身是有缺点的，他不能代替阻塞，自旋等待的时间必须有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程

自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更常的时间。如果对于某个锁，自旋很少成功获得，那在以后尝试获取这个锁时可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源



# 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁

这四种锁是指锁的状态，专门针对 synchorized 的，为什么 synchronized 能够实现线程同步？

两个重要的概念：**Java对象头**，**Monitor**

**对象头**

synchronized 时悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在 Java 对象头里的，而 Java 对象头优势什么呢？

我们以 Hotspot 虚拟机为例，Hotspot 的对象头主要包括两部分数据：Mark Word（标记字段），Klass Pointer（类型指针）

**Mark Word：**默认存储对象的 HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以 Mark Word 被设计成一个非固定的数据结构一边在极小的空间内存储尽量多的数据。它会根据对象的状态回复自己的存储空间，也就是说在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化

**Klass Point：**对象指向它的类元素数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

**Monitor** 

Monitor 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象，每一个Java对象就有一把看不见的锁，称为内部锁或者 Monitor 锁

Monitor 是线程私有的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有一个全局的可用列表。每个被锁住的对象都会和一个 monitor 关联，同时 monitor 种有一个 Owner 字段存放拥有该线程的唯一标识，表示该锁被这个线程占用。

sychonized 是通过 Monitor 来实现线程同步，Monitor 是依赖于底层的操作系统的 Mutex Lock （互斥锁）来实现线程同步



### **无锁**

无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个现车给能修改成功

### 偏向锁

偏向锁是指一段同步代码被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价

大多数情况下，锁总是有同一线程多次获得，不存在多线程竞争，所以出现了偏向锁，其姆堡就是在只有一个线程执行同步代码是能够提高性能

偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁

### 轻量级锁

指当锁是偏向锁的时候，被另外线程所访问，偏向锁就会升级为轻量级，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能

若当前只有一个线程等待，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁

### 重量级锁

升级为重量级锁时，锁标志的状态值变为 “10”，此时 Mark Word 种存储的时指向重量级锁的指针，此时等待锁升级的线程都会进入阻塞状态



综上：偏向锁通过对比 Mark Word 解决加锁问题，避免执行 CAS 操作，而轻量级锁时通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能，重量级锁是将处理拥有锁的线程以外的线程都阻塞



# 公平锁 VS 非公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列排队，队列中的第一个线程才能获得锁，公平锁的有点事等待锁的线程不会饿死。缺点是整体吞吐率相对非公平锁要低，等待队列中除第一个线程意外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大

非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。



# 可重入锁 VS 非可重入锁

可重入锁又叫递归锁，是指在同一个线程在外层方法获取锁的时候，在进入该线程的内层方法会自动获取锁（前提锁对象得到是同一个对象或者 class），不会因为之前已经获取过还没释放而阻塞。Java 中ReentrantLock 和 synchronized 都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。



# 独享锁 VS 共享锁

独享锁也叫排他锁，是指该锁一次只能被一个线程锁持有。如果线程 T 对数据A加上排它锁后，则其他线程不能再对 A 加任何类型的锁。获得排它锁的线程既能读数据又能修改数据。JDK synchronized 和 JUC 中 Lock 的实现类就是互斥锁

共享锁是指该锁可被多个线程持有。如果线程T对数据A加上共享锁，则其他线程只能对 A 再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。

独占锁与共享锁是通过 AQS 来实现的，通过实现不同的方法，来实现独占或者共享



# Java 并发重入锁 ReentrantLock

ReentrantLock 重入锁，是实现 Lock 接口的一个类，也是在实际编程中使用频率很高的一个锁，**支持重入性能，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞**

要想支持重入锁，需解决两个问题

1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功
2. 由于锁会被获取 n 次，那么只有在锁被释放同样的 n 次之后，该锁才算是完全释放成功



# Java并发读写锁 ReentrantReadWriteLock

**读写锁允许同一时刻被多个线程访问，但是在写线程访问时，所有的读线程和其他的线程都会被阻塞**

1. **公平性选择**：支持非公平性（默认）和公平的锁获取方式，吞吐量还是非公平优于公平
2. **重入性**：支持重入，都所获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁
3. **锁降级**：遵循获取锁，获取读锁再释放写锁的次序，写所能够降级成为读锁



几个问题：

1. 读写锁是怎样实现记录读写状态的？
2. 写锁是怎么样获取和释放的？
3. 读锁是怎样获取和是方法的？

### 写锁的获取

同步组件的实现聚合了同步器（AQS），并通过重写重写同步器（AQS）中的方法实现同步组件的同步语义，因此，写锁的实现依然采用这种方式。在同一时刻写锁是不能被多个线程获取，很显然写锁是独占式锁，而实现写锁的同步语义是通过重写 AQS 中的 tryAcquire 方法实现的



**tryAcquire** 主要实现逻辑为：**当读锁已经被线程获取或者写锁已经被其他线程获取，则写锁获取失败；否则，获取成功并支持重入，增加写状态**



### 写锁的释放

```java
protected final boolean tryRelease(int releases) {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
	//1. 同步状态减去写状态
    int nextc = getState() - releases;
	//2. 当前写状态是否为0，为0则释放写锁
    boolean free = exclusiveCount(nextc) == 0;
    if (free)
        setExclusiveOwnerThread(null);
	//3. 不为0则更新同步状态
    setState(nextc);
    return free;
}
```

只需要用 **当前同步状态直接去写状态的原因是我们刚才所说的写状态是由同步状态的低 16 位表示的**



### 读锁的获取

读锁不是独占式锁，即同一时刻可以被多个读线程获取也就是一种共享式锁。

当写锁被其他线程获取后，读锁获取失败，否则获取成功利用 CAS 更新同步状态



### 锁降级

读写锁支持降级锁，**遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁**



















