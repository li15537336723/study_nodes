# JUC

## 什么是 JUC ？

juc就是java.util.concurrent工具包的简称。这是一个处理线程的工具包，从jdk1.5开始出现

目的就是为了更好的支持高并发任务。让开发者进行多线程编程时减少竞争条件和死锁的问题！

## 并发与并行

并发：同一时刻多线程操作同一个资源,交替执行

并行：多项工作一起执行，之后再进行汇总



**synchronized 与 lock 锁**

**juc 下的集合(容器)类**

**常用的三个辅助类**

- CountDownLatch
- CyclicBarrier
- Semaphore



## 锁

### synchronized 

作用：保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块

- synchronized修饰实例方法。
- synchronized修饰静态方法。
- synchronized修饰实例方法的代码块。
- synchronized修饰静态方法的代码块。

**synchronized 锁，到底锁的是谁？**

```java
/**
 * description:
 * 1. 标准情况下，两个线程先打印，发短信还是打电话？  1：发短信，2：打电话
 * 2. sendMsg延迟2秒中，两个线程先打印发短信还是打电话？ 1：发短信，2：打电话
 *
 * @author: lixianghong
 * @date: 2022/10/15 14:26
 */
public class Test1 {
  public static void main(String[] args) {
    Phone phone = new Phone();
    new Thread(() -> {
      phone.sendMsg();
    }, "A").start();

    new Thread(() -> {
      phone.call();
    }, "B").start();
  }
}

class Phone {

  // synchronized 锁的对象是方法的调用者
  // 两个方法用的是同一个锁，谁先拿到谁执行
  synchronized void sendMsg() {
    try {
      TimeUnit.SECONDS.sleep(3);
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    System.out.println("发短信");
  }

  synchronized void call() {
    System.out.println("打电话");
  }
}
```



```java
/**
 * description:
 *
 * @author: lixianghong
 * @date: 2022/10/15 14:34
 */
public class Test2 {
  public static void main(String[] args) {
    Phone2 phone1 = new Phone2();
    Phone2 phone2 = new Phone2();
    new Thread(() -> {
      phone1.sendMsg();
    }).start();

    new Thread(() -> {
//      phone1.hello();
      phone2.call();
    }).start();
  }
}

class Phone2 {
  // synchronized 锁的是方法的调用者
  public synchronized void sendMsg() {
//    try {
//      TimeUnit.SECONDS.sleep(2);
//    } catch (InterruptedException e) {
//      throw new RuntimeException(e);
//    }
    System.out.println("发短信");
  }

  public synchronized void call() {
    System.out.println("打电话");
  }

  // 没有锁
  public void hello() {
    System.out.println("hello");
  }

}
```



```java
/**
 * description:
 * 5. 增加两个静态的同步方法，只有一个对象，先打印 发短信？打电话？
 * 6. 两个对象！增加两个静态的同步方法，先打印 发短信？打电话
 *
 * @author: lixianghong
 * @date: 2022/10/15 14:39
 */
public class Test3 {
  public static void main(String[] args) {
    // 两个对象的 Class 类模板只有一个，static，锁的是 Class
    Phone3 phone1 = new Phone3();
    Phone3 phone2 = new Phone3();
    new Thread(() -> {
      phone1.sendMsg();
    }).start();

    try {
      TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    new Thread(() -> {
//      phone1.call();
      phone2.call();
    }).start();
  }
}

class Phone3{

  // synchronized 锁的是对象是方法的调用者
  // static 静态方法
  // 类一加载就有了，锁的是 Class
  public static synchronized void sendMsg() {
    try {
      TimeUnit.SECONDS.sleep(2);
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    System.out.println("发短信");
  }

  public static synchronized void call() {
    System.out.println("打电话");
  }
}
```



```java
/**
 * description:
 *
 * @author: lixianghong
 * @date: 2022/10/15 14:48
 */
public class Test4 {
  public static void main(String[] args) {
    // 如果都用 phone 去调用的话，发短信的方法锁的是整个类模板，普通同步方法锁的是方法，两把不同的锁，会先打印出 打电话
    Phone4 phone1 = new Phone4();
    Phone4 phone2 = new Phone4();

    new Thread(() -> {
      phone1.sendSms();
    }).start();

    new Thread(() -> {
      phone1.call();
//      phone2.call();
    }).start();

  }
}

class Phone4 {
  // 静态的同步方法，锁的是 Class 模板
  public static synchronized void sendSms() {
    try {
      TimeUnit.SECONDS.sleep(2);
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    System.out.println("发短信");
  }

  // 普通的同步方法  锁的调用者
  public synchronized void call() {
    System.out.println("打电话");
  }
}
```



### Lock

juc 下面的实现类：

1、可重入锁：ReentrantLock（最常用的）

2、读锁：ReentrantReadWriteLock.ReadLock 

3、写锁：ReentrantReadWriteLock.WriteLock



### 生产者和消费者的问题

synchronized版本		wait()   notify()  	notifyAll()

Lock版本		await()	signal() 	  signalAll()

> synchronized 版本

```java
public class A {
  public static void main(String[] args) {
    Data data = new Data();
    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          data.increment();
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "A").start();

    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          data.decrement();
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "B").start();
  }
}

// 等待 --》 执行业务操作---》唤醒
class Data {
  int num = 0;

  public synchronized void increment() throws InterruptedException {
    if (num != 0) {
      wait();
    }
    System.out.println(Thread.currentThread().getName() + "===>" + num);
    num++;
    // 唤醒的操作
    notifyAll();
  }

  public synchronized void decrement() throws InterruptedException {
    if (num == 0) {
      wait();
    }
    System.out.println(Thread.currentThread().getName() + "===>" + num);
    num--;
    // 唤醒其他线程
    notifyAll();
  }
}
```



> JUC 版本

通过 Lock 找到 Condition 

Condition：取代了对象监视器方法(wait,notify)的使用

```java
public class A {
  public static void main(String[] args) {
    Data data = new Data();
    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          data.increment();
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "A").start();

    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          data.decrement();
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "B").start();
  }
}

// 等待 --》 执行业务操作---》唤醒
class Data {
  int num = 0;

  public synchronized void increment() throws InterruptedException {
    if (num != 0){
      wait();
    }
    System.out.println(Thread.currentThread().getName() + "===>" + num);
    num++;
    // 唤醒的操作
    notifyAll();
  }

  public synchronized void decrement() throws InterruptedException {
    if (num == 0) {
      wait();
    }
    System.out.println(Thread.currentThread().getName() + "===>" + num);
    num--;
    // 唤醒其他线程
    notifyAll();
  }
}
```



### synchorinzed 与 lock区别

1、Synchronized 内置的 Java 关键字，Lock 是一个 Java类

2、Synchronized 无法判断获取锁的状态，Lock 可以判断是否获取到了锁

3、Synchronized 会自动释放锁，lock 必须要手动释放，如果不释放，**死锁**

4、Synchronized 线程1（获得锁，阻塞），线程2（等待），Lock锁就不一定会等待下去

5、Synchronized 可重入锁，不可以中断，非公平；Lock，可重入锁，可以判断锁，非公平（可以自己设置）

6、Synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码



## juc 下的集合类

常用集合 `List`，`set`，`map`

**list**

```java
public static void main(String[] args) {
    /*
      解决方案
      1. List<String> list = new Vector<>();
      2. List<String> list = Collections.synchronizedList(new ArrayList<>());
      3. List<String> list = new CopyOnWriteArrayList<>();
     */
    // List<String> list = Collections.synchronizedList(new ArrayList<>());
    // CopyOnWrite 写入时复制  COW 计算机程序设计领域的一种优化策略
    // 多个线程在调用的时候，list，读取的时候，固定的，写入（覆盖）
    // 再写入的时候避免覆盖，造成数据问题！
    // 读写分离
    // CopyOnWriteArrayList 比 Vector 更牛，底层使用的是 Lock 锁
    List<String> list = new CopyOnWriteArrayList<>();
    for (int i = 0; i < 10; i++) {
        new Thread(() -> {
            list.add(UUID.randomUUID().toString().substring(0, 5));
            System.out.println(list);
        }, String.valueOf(i)).start();
    }
}
```

**Set**

```java 
public static void main(String[] args) {
    //    Set<String> set = new HashSet<>();
    //    Set<String> set = Collections.synchronizedSet(new HashSet<>());
    Set<String> set = new CopyOnWriteArraySet<>();
    for (int i = 0; i < 30; i++) {
        new Thread(() -> {
            set.add(UUID.randomUUID().toString().substring(0, 5));
            System.out.println(set);
        }, String.valueOf(i)).start();
    }
}
```



**hash**

concurrentHashMap怎么保证线程安全

JDK1.7

**存储结构采用 Segment 数组 + HashEntry 数组 + 链表**

但是 `Segment` 的个数一旦**初始化就不能改变**

**一、初始化**

三个参数

1. 默认初始化容量 —— 16
2. 默认负载因子 —— 0.75f
3. 默认并发级别 —— 16

**二、put**

首先检查 Segment 是不是空，来确定要不要初始化

1. 计算要 put 的 key 的为止，获取指定为止的 segment

2. 如果指定的位置 segment 为空，则初始化这个 segment

   **segment 初始化流程**

   1. 检查校验准备工作
   2. 自旋判断指定位置的 Segment 是否为 null，使用 CAS 在这个位置赋值为 Segment

3. `Segment.put` 插入 `(key,value)` 的值



`Segment.put`

1. `tryLock()` 获取锁，获取不到使用 **`scanAndLockForPut`** 方法继续获取。
2. 使用 CAS 获取index坐标的值
3. 遍历进行一系列操作，主要进行修改和解决hash冲突的操作

**三、扩容**

将新的容量增加到原来的 2 倍，采用头插法插入到指定的位置



JDK1.8

**存储结构采用 Node 数组 + 链表 / 红黑树**

**一、初始化**

1. 使用 自旋和CAS 来完成的

**二、put**

1. 判断是否需要初始化，数组为空或者长度为0进行初始化
2. 当前key定位出的node如果是空写入数据，否则CAS操作
3. 使用 synchronized 锁，先进行链表的插入或者覆盖操作，在进行树形结构的操作



List ==>  copyOnWriteArrayList

Set ===> copyOnWriteHashSet

Map ==>ConCurrentHashMap



## CountDownLatch

减法计数器

`countDown()` 数量减一的操作

`await()` 等待计数器归零，然后再向下执行

```java
public static void main(String[] args) throws InterruptedException {
    // 总数是6，必须要执行任务的时候，再使用
    CountDownLatch countDownLatch = new CountDownLatch(6);

    for (int i = 1; i <= 6; i++) {
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " Go out");
            countDownLatch.countDown();   // 数量 0-1
        }, String.valueOf(i)).start();
    }
    countDownLatch.await();
    System.out.println("close door");
}
```



## CyclicBarrier

加法计数器

```java
public static void main(String[] args) {
    CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
        System.out.println("777777777");
    });

    for (int i = 1; i <= 7; i++) {
        final int temp = i;
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " --》 " + temp );
            try {
                cyclicBarrier.await();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }, String.valueOf(i)).start();
    }
}
```



## Semaphore

一个计数信号量。信号量位置一组许可证。如果有必要，每个 acquire() 都会阻塞，直到许可证可用，然后才能使用它

信号量中的两个方法

`acquire()` 得到，如果已经完了，等待，等待被释放为止

`release()` 释放，会将当前的信号量释放 +1，然后唤醒等待的线程

作用：多个共享资源互斥的使用！并发限流，控制最大的线程数！

```java
public static void main(String[] args) {
    // 线程数量：停车位, 限流
    Semaphore semaphore = new Semaphore(3);

    for (int i = 1; i <= 6; i++) {
        new Thread(()->{
            // acquire() 得到
            try {
                semaphore.acquire();
                System.out.println(Thread.currentThread().getName() + " 得到了车位");
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + " 离开车位");
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                semaphore.release();// release() 释放
            }
        }, String.valueOf(i)).start();
    }
}
```





