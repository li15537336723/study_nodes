## 什么是JUC

### wait/sleep 的区别

1. sleep 是 Thread 静态方法，wait 是 Object 的方法，任何对象实例都能调用
2. sleep 不会释放锁，他也不需要占用锁。wait 会释放锁，但调用它的前提是当前线程占有锁（及代码要在 synchronized 中）。
3. 他们都可以被 interrupted 方法中断





## 多线程编程步骤

第一步：创建资源类，在资源类创建属性和操作方法

第二步：创建多个线程，调用资源类的操作方法



## 线程之间的通信

使用 `synchronized` 方式

```java
// 第一步：创建资源类，定义属性和操作方法
class Share {
  // 初始值
  private int number = 0;
  // +1 的方法
  public synchronized void incr() throws InterruptedException {
    // 第二步：判断 干活 通知
    while (number != 0) {// 判断 number 值是否是0，如果不是0，等待
      this.wait();
    }
    number++;
    System.out.println(Thread.currentThread().getName() + "::" + number);
    // 通知其他线程
    this.notifyAll();
  }

  // -1 的方法
  public synchronized void decr() throws InterruptedException {
    // 第二步：判断 干活 通知
    while (number != 1) {
      this.wait();
    }
    // 干活
    number--;
    System.out.println(Thread.currentThread().getName() + "::" + number);
    // 通知其他线程
    this.notifyAll();
  }
}
public class ThreadDemo1 {
  // 第三步：创建多个线程，调用资源类的操作方法
  public static void main(String[] args) {
    Share share = new Share();
    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          share.incr();// +1
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "AA").start();

    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          share.decr(); // -1
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "BB").start();

    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          share.incr(); // -1
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "CC").start();

    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          share.decr(); // -1
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "DD").start();
  }
}
```



使用 `Lock` 方法

```java
class Share {
  private int number = 0;

  // 创建 Lock
  private Lock lock = new ReentrantLock();
  private Condition condition = lock.newCondition();

  // +1
  public void incr() throws InterruptedException {
    // 上锁
    lock.lock();
    try {
      // 判断
      while (number != 0) {
        condition.await();
      }
      // 干活
      number++;
      System.out.println(Thread.currentThread().getName() + "::" + number);
      /// 通知
      condition.signalAll();
    } finally {
      // 解锁
      lock.unlock();
    }
  }

  // -1
  public void decr() throws InterruptedException {
    lock.lock();
    try {
      while (number != 1) {
        condition.await();
      }
      number--;
      System.out.println(Thread.currentThread().getName() + "::" + number);
      condition.signalAll();
    } finally {
      lock.unlock();
    }
  }
}

public class ThreadDemo2 {
  public static void main(String[] args) {
    Share share = new Share();
    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          share.incr();
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "AA").start();

    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          share.decr();
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "BB").start();

    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          share.incr();
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "CC").start();

    new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        try {
          share.decr();
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }, "DD").start();
  }
}
```



## 线程间的定制化通信

启动三个线程，按照如下要求：

- AA 打印 5 次，BB 打印 10 次，CC 打印 15 次
- AA 打印 5 次，BB 打印 10 次，CC 打印 15 次

进行 10 轮

<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220512160415604.png" alt="image-20220512160415604" style="zoom: 50%;" />



## 公平锁 / 非公平锁

```java
private final ReentrantLock lock = new ReentrantLock(true);
```

`ReentrantLock` 源码

```java
public ReentrantLock() {
    sync = new NonfairSync();
}

/**
 * Creates an instance of {@code ReentrantLock} with the
 * given fairness policy.
 *
 * @param fair {@code true} if this lock should use a fair ordering policy
 */
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

方法中可以传递一个 **布尔** 类型的参数，表示是否是公平锁。

> 非公平锁特点：效率高，可能出现线程饿死
>
> 公平锁特点：效率相对较低，阳光普照，每个线程都有可能用上





## 可重入锁

`synchronized` 和 `Lock` 都是可重入锁

`synchronized` 是隐式的

`Lock` 是显式的

隐式指自动上锁解锁，显示指手动上锁和解锁

**可重入锁**也称为递归锁，进入第一道大门之后也可以进入第二道大门

<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220516145043015.png" alt="image-20220516145043015" style="zoom:50%;" />

```java
// synchronized
Object o = new Object();
new Thread(() -> {
  synchronized (o) {
    System.out.println(Thread.currentThread().getName() + "外");
    synchronized (o) {
      System.out.println(Thread.currentThread().getName() + "中");
      synchronized (o) {
        System.out.println(Thread.currentThread().getName() + "内");
      }
    }
  }
}, "t1").start();
```



```java
// Lock 演示可重入锁
Lock lock = new ReentrantLock();
// 创建线程
new Thread(() -> {
    try {
        lock.lock();
        System.out.println(Thread.currentThread().getName() + "外城");

        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName() + "内层");
        } finally {
            lock.unlock();
        }
    } finally {
        lock.unlock();
    }

}, "t1").start();
```



## 死锁

### 什么是死锁

两个或者两个以上进程在执行过程中，因为争夺资源而互相等待的一种现象，如果没有外力干涉，他们无法再执行下去。

<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220516145437516.png" alt="image-20220516145437516" style="zoom:50%;" />

### 产生原因

1. 系统资源不足
2. 进程运行推荐顺序不合适
3. 资源分配不当



**死锁代码演示**

```java
// 创建两个对象
static Object a = new Object();
static Object b = new Object();

public static void main(String[] args) {
    new Thread(() -> {
        synchronized (a) {
            System.out.println(Thread.currentThread().getName() + "持有锁A，试图获取锁B");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            synchronized (b) {
                System.out.println(Thread.currentThread().getName() + "获取锁B");
            }
        }
    },"A").start();

    new Thread(() -> {
        synchronized (b) {
            System.out.println(Thread.currentThread().getName() + "持有锁B，试图去获取锁A");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            synchronized (a) {
                System.out.println(Thread.currentThread().getName() + "获取锁A");
            }
        }
    },"B").start();
}
```



### 读写锁

**读写锁：**一个资源可以被多个读线程访问，或者可以被一个写线程访问，但是不能同时存在读写线程，读写互斥，读读共享

读读：可以共享，提升性能，同时多人进行读操作

写写：不可以共享，最多只能有1个人

**读写锁缺点：**

1. 造成锁饥饿，一直读，没有写操作，写的时候不能有读锁在占着，但是因为读锁是共享的，假如读并发很多的时候，写锁就会一直进不去，也就是锁饥饿
2. 读时候，不能写， 只有都完成之后，才可以写，写操作可以读



## 阻塞队列

阻塞队列：首先是一个队列，通过一个共享的队列，可以使得数据由队列的一端输入，从另一端输出

<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220521143813931.png" alt="image-20220521143813931" style="zoom:50%;" />

当队列是空的，从队列中获取元素的操作将会被阻塞

当队列是满的，从队列中添加元素的操作将会被阻塞

试图从空的队列中获取元素的线程将会被阻塞，知道其他线程往空的队列插入新的元素

试图向已满的队列中添加新元素的线程将会被阻塞，知道其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增



## 线程池

线程池：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。

例如：10年前单核 CPU 电脑，假的多线程，CPU 需要来回切换，现在是多核电脑，多个线程各自跑在独立的 CPU 上，不用切换效率高

**线程池优势：**线程池做的工作只是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超对数量的线程等待排序，等其他线程执行完毕，再从队列中取出任务来执行。

**主要特点：**

- 降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗
- 提高相应速度：当任务达到时，任务可以不需要等待先创建就能立即执行
- 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一的分配，调优和监控。
- **Java中的线程池是通过哦Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor 这几个类**



```java
// 常驻线程数量
int corePoolSize,
// 最大线程数量
int maximumPoolSize,
// 线程存活时间
long keepAliveTime,
TimeUnit unit,
// 阻塞队列
BlockingQueue<Runnable> workQueue,
// 线程工厂
ThreadFactory threadFactory,
// 拒绝策略
RejectedExecutionHandler handler
```



