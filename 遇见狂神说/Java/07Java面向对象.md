# 01：类与对象的关系

- 类是一种抽象的数据类型，它是堆某一类事物整体描述/定义，但是并不能代表某一个具体的事物。
  - 动物，植物，手机，电脑..........
  - Person类，Pet类，Car类等，这些类都是用来描述/定义某一类具体事物应该具备的特点和行为
- 对象是抽象概念的具体实例
  - 张三就是人的一个具体实例，张三家里的旺财就是狗的一个具体实例。
  - 能够体现出特点，展示出功能的是具体的实例，而不是一个抽象的概念。

## 构造器

- 使用new关键字创建对象
- 使用new关键字创建对象的时候，除了分配内存空间之外，还会给创建好的对象进行默认初始化以及对类中构造器的调用
- 类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点：
  - 必须和类名相同
  - 必须没有返回类型，也不能写void

- **构造器必须掌握**

```java
String name;	// 默认为null
int age;		// 0

public Student() {

}
```



# 02：封装

- 该露的露，该藏的藏
  - 我们程序设计需要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细解自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用

- 封装（数据的隐藏）
  - 通常，应禁止直接访问一个对象中数据的实际表示，而应通过接口来访问，这称为信息隐藏。
- 记住这句话就够了：**属性私有，get/set**

### 作用

1. 提高程序的安全性，保护数据
2. 隐藏代码的实现细节
3. 统一接口
4. 系统可维护性增加了

# 03继承

- 继承本质是对某一批类的抽象，从而实现对世界更好的建模

- extends的意思是“扩展”。字类是父类的扩展
- Java中类只有单继承，没有多继承
- 继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖，组合，聚合等。
- 继承关系的俩个类，一个为子类（派生类），一个为父类（基类）。字类继承父类，使用关键字extends来表示
- 字类和父类之间，从意义上讲应该具有“is a”的关系

- object类
- super
- 方法重写

### super注意点

1. super调用父类的构造方法，必须在构造方法的第一行
2. super必须只能出现在字类方法或者构造方法中！
3. super和this不能同时调用构造方法

### super VS this

1. 代表的对象不同

   this: 本身调用者这个对象

   super：代表父类对象的应用

2. 前提：

   this:  没有继承也可以使用

   super：只能在继承条件才可以使用

3. 构造方法

   this()：本类的构造方法

   super()：父类的构造

### 重写

需要有继承关系，子类重写父类的方法！

1. 方法名必须相同
2. 参数列表必须相同
3. 修饰符：范围可以扩大：

重写，字类方法和父类方法必须一致：方法体不同！

为什么需要重写：

1. 父类的功能，字类不一定需要，或者不一定满足！



# 多态

- 动态编译：类型
- 即一个方法可以根据发送对象的不同而采用多种不同的行为方式
- 一个对象的实际类型是确定的，但可以指向队形的引用的类型有很多
- 多态存在的条件
  - 有继承关系
  - 子类重写父类方法
  - 父类引用指向字类对象
- **注意：多态是方法的多态，属性没有多态性**
- **instance of    类型转换~ 引用类型之间的转换**    

### 多态注意事项：

1. 多态是方法的多态，属性没有多态
2. 父类和子类，有联系，类型转换异常！ClassCastException!
3. 存在条件：继承关系，方法需要重写       Father f1 = new Son();



#### 不能被重写的方法

	1. static 方法：属于类，不属于实例
 	2. final：常量
 	3. private方法：私有的，不能被重写





## 类型转化

1. 父类引用指向子类的对象
2. 把子类转换为父类，向上转型
3. 把父类转换为子类，向下转型：强制转换
4. 方便方法的调用，减少重复的代码，简洁

抽象：封装，继承，多态！



# 抽象类

- abstract 修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法；如果修饰类，那么该类就是抽象类

- 抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类
- 抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。
- 抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。
- 子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。

# 接口

- 普通类：只有具体实现
- 抽象类：具体实现和规范（抽象方法）都有！
- 接口：只有规范！自己无法写方法~专业的约束！约束的实现分离：面向接口编程

- 接口就是规范，定义的是一组规则，体现了实现世界中”如果你是，，，则必须能，，，“的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑，，，，，，，，，，，，，
- 接口的本质是锲约，就像我们人间的法律一样。制定好后大家都遵守
- OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式只针对具备了抽象能力的语言(比如C++，java，C#等，就是因为设计模式所研究的，实际上就是如何合理的去抽象)

```java
// 接口都需要 有实现类
public interface UserService {
	// 接口中的所有定义其实都是抽象的 public    abstract
	public void add(String name);
	public void delete(String name);
	public void update(String name);
	public void query(String name);
}
```

```java
    // 抽象类：extends~
    // 类 可以实现接口， implements 接口
    // 实现了接口的类，就需要重写接口中的方法
	public class UserServiceImpl implements UserService {

    @Override
    public void add(String name) {
        // TODO Auto-generated method stub

    }

    @Override
    public void delete(String name) {
        // TODO Auto-generated method stub

    }

    @Override
    public void update(String name) {
        // TODO Auto-generated method stub

    }

    @Override
    public void query(String name) {
        // TODO Auto-generated method stub

    }
```

接口作用

1. 约束
2. 定义一些方法，让不同的人实现
3. public     abstract
4. public     static    final
5. 接口不能别实例化，接口中没有构造方法
6. implements可以实现多个接口
7. 必须要重写接口中的方法



# 内部类

内部类就是在一个类的内部再定义一个类，比如，A类中定义一个B类，那么B类中相对A类来说就称为内部类，而A类相对B类来说就是外部类了。

1. 成员内部类
2. 静态内部类
3. 布局内部类
4. 匿名内部类

















