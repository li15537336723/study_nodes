## Redis 缓存穿透和雪崩

![image-20210731161752659](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210731161752659.png)

### 缓存穿透



> 概念

缓存穿透的概念很简单，用户想要查询一个数据，发现 Redis 内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败，当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。

> 解决方案

#### 布隆过滤器

布隆过滤器是一种数据结构，对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；

![image-20210731161928069](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210731161928069.png)



#### 缓存空对象

当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据会从缓存中获取，保护了后端数据源

![image-20210731162054689](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210731162054689.png)

但是这种方法会存在两个问题：

1、如果空值能被缓存起来，这就意味着缓存需要更多的空间存储更多的建，因为这当中可能会有很多的空值的键；

2、即使对空值设置了过期时间，还是会存在缓存层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。



### 缓存击穿（量太大，缓存过期）

> 概述

这里需要注意和缓存击穿的区别， 缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就行一个屏障上凿开了一个洞。

当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且写回缓存，会导致数据库瞬间压力过大。



> 解决方案

**设置热点数据永不过期**

从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题

**加互斥锁**

分布式锁：使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端服务，其他线程没有活得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考研很大。

















































