# 索引优化



## 1. SQL 性能下降原因



1. 查询语句写的烂
2. 索引失效 —— 单值/复合
3. 关联查询太多 join （设计缺陷或不得已的需求）
4. 服务器调优以及各个参数设置（缓冲，线程数等）



## 2. SQL 执行加载顺序

![image-20210722115145661](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210722115145661.png)





## 3. 索引是什么



官方定义：索引是帮助MySQL搞笑获取数据的数据结构。可以得到索引的本质：索引是数据结构

可以简单的理解为：排好序的快速查找数据结构

<font color="blue">数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构一某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引</font>

索引本身也很大，不可能全部存在内存中，因此索引往往以文件的形式存储在磁盘上。



## 4. 索引的优劣势



**优势：**类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的 IO 成本，通过索引列对数据进行排序，降低数据排序的成本，降低了 CPU 的消耗

**劣势：** 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT，UPDATE 和 DELETE。因为表更新是，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新问题带来的简直变化后的索引信息。

索引只是提高效率的一个因素，如果你的 mysql 有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询





## 5. 索引分类和建立索引



### 5.1 SQL 索引分类

**单值索引：** 即一个索引只包含单个列，一个表可以有多个单列索引

**唯一索引：** 索引列的值必须唯一，但允许为空

**复合索引：** 即一个索引包含多个列

**基本语法：** 

```sql
# 创建
create [unique] index indexName on myTable(字段名)
create myTable add [unique] index [indexName] on (字段名)
# 删除
drop index [indexName] on mytable
# 查看
show index from table_name \G
```



## 6. 建立索引前提



### 6.1 那些情况要建立索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中与其他表关联的字段，外键关系建立索引
4. 频繁更新的字段不适合创建索引——因为每次更新不单单是更新了记录还会更新索引
5. where 条件里用不到的字段不创建索引
6. 单件 / 组合索引的选中问题
7. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
8. 查询中统计或者分组字段



### 6.2 那些情况不建立索引



1. 标记了太少
2. 经常增删改的表
3. 数据重复且分布平均的表字段，因此应该为最经常查询和最经常排序的数据列建立索引



## 7. 性能分析 —— Explain



### 7.1 Explain 可以干什么



1. 表的读取顺序
2. 数据读取操作的数据类型
3. 那些索引可以使用
4. 那些索引被实际使用
5. 表之间的引用
6. 每张表有多少行被优化器查询



### 7.2 怎么用



`Explain + SQL语句`

![image-20210722151127517](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210722151127517.png)



### 7.3 各字段解释

#### 7.3.1 id

select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序

**三种情况**

1. id 相同，执行顺序由上至下
2. id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行
3. id 相同不同，同时存在



#### 7.3.2 select_type

<img src="C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210722153130052.png" alt="image-20210722153130052" style="zoom:67%;" />

查询的类型，主要用于区别

普通查询，联合查询，子查询等的复杂查询



1. **simple** —— 检查的select查询，查询中不包含子查询或者 union
2. **primary** —— 查询中若包含任何复杂的子部分，最外层查询则被标记
3. **subquery** —— 在 select 或 where 列表中包含了子查询
4. **Derived** —— 在 from 列表中包含的子查询被标记为 derived （衍生）MySQL 会递归执行这些子查询，把结果放在临时表里。
5. **union** —— 若第二个 select 出现在union之后，则被标记为 union，若union 包含在 from 子句的子查询中，外层select 将被标记为：Deired
6. **union result** —— 从 union 表获取结果的select



#### 7.3.3 table



显示这一行的数据是关于那张表的



#### 7.3.4 type

![image-20210722154313225](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210722154313225.png)

访问类型排列

显示查询使用了何种类型

<font color="red">从最好道最差依次是：</font> system > const > eq_ref > range > index > all



`system`

表只有一行记录（等于系统表），这是 const 类型的特例，平时不会出现，这个也可以忽略不计

`const`

表示通过索引依次就找到了，const 用于比较primary key或者unique索引。因为只匹配一行数据，所以很快

如将主键至于 where 列表中，MySQL 就能将该查询转换为一个常量

`eq_ref`

唯一性索引扫描，对于每个索引键，表中只有一套记录与之匹配。常见于主键或唯一索引扫描

`ref`

非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，他可能会找到多个符合条件得行，所以他应该属于查找和扫描的混合体

`range`

只检索给定范围的行，使用一个索引来选择。key 列显示使用了那个索引，一般就是在你的 where 语句中出现了 between，<，>，in 等的查询

这种范围扫描索引扫描比全表扫描要好，因为她只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引

`index`

Full Index Scan，index 与 ALl 区别为 index类型只遍历索引树。这通常比 all 快，因为索引文件通常比数据文件小。（<font color="blue">也就是说虽然 all 和 index 都是读全表</font>，但 index 是从索引中读取的，而 All 是从硬盘中读的）

`all`

Full Table Scan，将遍历全表以找到匹配的行

<font color = "red">一般来说，得保证查询至少达到 reange 级别，最好能达到 ref</font>



#### 7.4.5 possible_kys、key



`possible_keys`

**显示可能应用在这张表中的索引，一个或多个**。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用

`key`

**实际使用的索引**。如果为 null，则没有使用索引，查询中若使用了覆盖索引，则该索引仅出现在 key 列表中。



#### 7.4.6 key_len



表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好

key_len 显示的值为索引字段的最大可能长度，<font color = "red">并非实际使用长度</font>，即 key_len 是根据表定义计算而得，不是通过表内检索出的



#### 7.4.7 ref



显示索引的哪一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值。



#### 7.4.8 rows



根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数



#### 7.4.9 extra



包含不适合在其他列中显示但十分重要的额外信息



## 8. 索引优化





























































