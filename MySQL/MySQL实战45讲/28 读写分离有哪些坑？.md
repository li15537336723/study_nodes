# 28 | 读写分离有哪些坑？

主要问题：读写分离，以及怎么处理主备延迟导致的读写分离问题

## 一主多从结构如下

<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220328111846955.png" alt="image-20220328111846955" style="zoom:50%;" />

读写分离的主要目标就是分摊主库的压力。上图中的情况是由客户端选择后端数据库进行查询。

还有一种架构是，在 MySQL 和客户端之间有一个中间代理层 proxy，客户端只连接 proxy，由 proxy 根据请求类型和上下文决定请求的分发路由

<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220328112107144.png" alt="image-20220328112107144" style="zoom:50%;" />



上面两种架构都会遇到的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读取到刚刚事务提交之前的状态

**这种 “在从库上会读到系统的一个过期状态” 的现象，暂时称为 “过期读”**



## 解决 **过期读** 的方案

- 强走主库方案
- sleep 方案
- 判断主备无延迟方案
- 配合 semi-sync 方案
- 等主库位点方案
- 等 GTID 方案



### 强走主库方案

将查询请求做分类。

1. 对于必须要拿到的最新结果请求，讲查询强制发生在主库上。比如，交易平台卖家发布之后需要查看是否发布成功，那么这个请求需要拿到最新的结果，就必须走主库。
2. 对于可以读到旧数据的请求，才将其发送到从库上。在这个交易平台上，买家逛店铺页面，就算晚几秒钟看到最新发布的也是可以接受的。



### Sleep 方案

主库更新后，读从库之前先 sleep 一下，具体的方案就算，类似于执行一条 select sleep(1) 命令。

这个方案的假设是，大多数情况下主备延迟 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据。

sleep 方案确实解决了类似卖家发布商品场景下过期读的问题，但是，从严格意义上来说，这个方案存在的问题就算不精确。这个不精确包含了两层意思：

1. 如果这个查询请求本来来 0.5 秒就可以在从库上拿到正确结果，也会等 1 秒
2. 如果延迟超过 1 秒，还是会出现过期读。



### semi-scyn 

1. 事务提交的时候，从库把 binlog 发给从库
2. 从库收到 binlog 以后，返回给主库一个 ack，表示收到了
3. 主库收到这个 ack 以后，才能给客户端返回 “事务完成”的确认。

也就是说，如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到这个日志。

这样看着似乎解决了问题，但是 semi-sync 只对一主一从的场景是成立的。在一主多从场景中，主库只要等到一个从库 ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：

1. 如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据
2. 但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。



semi-sync 配合判断主备无延迟的方案，存在两个问题：

1. 一主多从的时候，在某些从库执行查询请求会存在过期读的现象
2. 在持续延迟的情况下，可能出现过度等待的问题。







