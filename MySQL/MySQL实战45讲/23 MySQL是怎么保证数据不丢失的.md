# 03 | MySQL是怎么保证数据不丢失的？

首先直接看结论：只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后数据可以恢复。



## binlog 的写入机制

binlog 的写入逻辑比较简单，事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写道binlog 文件中。

一个事务的 binlog 是不能被拆开的，因此不管这个事务有多大，也要确保一次性写入。但是 binlog cache 的内存是有大小的，这我们就需要牵扯到 binlog cache 的保存问题

系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过这个参数规定的大小，就需要先存到磁盘中了。



事务提交的时候，执行器把 binlog cache 里的完整事务写到了 binlog 中，并清空 binlog cache

<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220321084600836.png" alt="image-20220321084600836" style="zoom: 67%;" />

- 图中的 write 指的就是把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。

- 图中 fsync，才将数据持久化到磁盘的操作，一般情况下，我们认为 fsync 才占磁盘的 IOPS。

write 和 fsync 的时机，是由参数 sync_binlog 控制的：

1. sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync；
2. sync_binlog = 1 的时候，表示每次提交事务都执行 fsync；
3. sync_binlog = N (N > 1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。



一般在 IO 瓶颈场景里，会将 sync_binlog 设置成一个较大值，一般是 100 ~ 1000中的某个数值。

但是将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的binlog 日志。





## redo log 的写入机制

问题：

1. redo log buffer 里面的内容，是不是每次生成后都要直接持久化到磁盘呢？

   **答案：不需要**

   如果事务执行期间 MySQL 发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。

2. 事务还没有提交的时候，redo log buffer 中的部分日志有没有可能被持久化到磁盘？

   **答案：确实会有**



  第二个问题重 redo log 可能存在的三种状态说起，三种状态如下图

![image-20220321085717110](https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220321085717110.png)

解释：

1. 存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中红色部分
2. 写到磁盘（write），但是没有持久化 fsync，物理上是在文件系统的 apge cache 里面，也就是图中黄色部分
3. 持久化到磁盘，对应的是 hard disk，也就是图中绿色部分

InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。



有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。

1. **redo log buffer 占用的空间即将达到 Innodb_log_buffer_size 一半的时候，后台线程会主动写盘**

2. **并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘**

 两阶段，先 prepare，再写 binlog，最后再把 redo log commit。



### 日志逻辑序列号 —— LSN

LSN 是单调递增的，用来对应 redo log 的一个个写入点。每次写入长度为 length 的 redo log，LSN的值就会加上 length。

看下面三个并发事务（trx1，trx2，trx3）在prepare 阶段，都写完了 redo log buffer ，持久化到磁盘的过程，对应 LSN 分别是 50，120，160.

<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220321095318004.png" alt="image-20220321095318004" style="zoom:67%;" />

1. trx1 是第一个到达的，会被选为这组的 leader
2. 等 trx1 要开始写盘的时候，这个组里面已经有三个事务，这时候 LSN 也变成了 160
3. trx1 去写盘的时候，带的就是 LSN = 160，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘。
4. 这个时候 trx2 和 trx3 就可以直接返回了。

































































































































































































































































































































































































































































































