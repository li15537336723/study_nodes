# 01 | 基础框架：一条 SQL 查询语句时如何执行的？

## 第二版总结

MySQL可以分为Server层和存储引擎层两部分

Server层包括**连接器、查询缓存、分析器、优化器、执行器**等

第一步（连接器）：首先会进行连接，默认的连接时间是 8 个小时

第二步（查询缓存）：连接成功后先看看缓存中有没有，如果有则是以 key-value 的形式，直接返回就不需要后续的操作，效率会很高。==注意：不建议使用缓存，往往利大于弊，只要有对一个表更新，有可能还没有使用，只要已更新缓存就会被清除==

第三步（分析器）：先进行词法解析(解析出来 select，表明等关键字)，在进行语法解析，根据语法规则，判断输入的这个 SQL 语句是否满足 MySQL 语法

第四步（优化器）：执行之前数据库先进行一次优化，例如 join 两个表的位置是合适等

第五步（执行器）：先看看有没有执行查询的权限，没有就返回没有权限的错误



















## 一条的 SQL 语句

```sql
select * from T where ID = 10
```

我们看到的只是输入一条语句，返回一个结果，却不知道这条 SQL 内部的执行过程。

看下图的基本框架示意图：

<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220208170502407.png" alt="image-20220208170502407" style="zoom:67%;" />

总体上来说，MySQL查询过程分为两成：Server层和存储引擎层



**Server 层**包括连接器，查询缓存，分析器，优化器，执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（日期，时间，数学，加密函数等）

**存储引擎层**负责数据的存储和提取。

从上图中我们不难看出，不同的存储引擎共用一个 **Server 层**，也就是从连接器到执行器的部分。



## 连接器

第一步：连接数据库。连接器负责与客户端建立连接，获取权限，维持和管理连接。

```sql
mysql -h$ip -P$port -u$user -p
```

- 长连接：指连接成功之后，如果客户端持有请求，则一直使用同一个连接。
- 短连接：指每次执行完很少的几次查询就断开连接，下次连接重新建立一个。

**在开发中尽量使用长链接**

**==注意：==**全部使用长连接后，我们会发现有些时候 MySQL 占用的内存涨的特别快，因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以长链接积累下来，可能导致内存占用太大，被系统强行杀掉，从现象来看就是 MySQL 异常重启了。

**怎么解决上述的问题**

1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后查询再重连。
2. MySQL 5.7 版本，可以在执行又给比较大的操作后，通过执行 mysql_reset——connection 来重新初始化连接资源。



## 查询缓存

建立完连接，就可以执行 select 语句执行查询缓存

MySQL 拿到一个查询语句之后会先在缓存中看看，之前是不是执行过这个语句，之前执行的可能是以 key - value 对的形式，被直接缓存在内存中。key 是查询语句，value 是结果。如果在缓存中找到了这个key，那么这个value就会被直接返回给客户端。

如果语句不在缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。如果查询命中缓存，MySQL 将不会执行后续的操作，就可以直接返回结果。

**注意：查询缓存往往弊大于利**

查询缓存失效非常频繁，只要有对于一个表的更新，这个表上所有缓存都会被清空。这就导致了出现一个数据被存起来还没有被使用，就被一个更新的操作给全部清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常底。



## 分析器

如果没有命中缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析



**第一步：**分析器首先会做 “词法分析” 。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么？代表什么？

**第二步：**做 “语法分析” 。根据词法分析的结果，语法分析器会根据语法规则，判断输入的这个 SQL 语句是否满足 MySQL 语法

假如我们的语句写错了，select 写成了 elect，则会报错



## 优化器

经过了分析器，MySQL 就知道你要做什么了。在开始执行之前还要先经过优化器的处理。

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联 (`join`) 的时候，决定各个表的连接顺序。比如下面这条语句

```sql
select * from t1 join t2 using(ID) where t1.c = 10 and t2.d = 20;
```

既可以先从表 t1 里面取出 c = 10 记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。

也可以先从表 t2 里面去除 d = 20 记录的 ID 值，再根据 ID 值关联到表 t1，再判断 t1 里面 c 的值是否等于 10。

这两种执行方法的逻辑结果是一样，但是执行的效率会有不同，而优化器的作用就是决定使用哪一个方案。

优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。



## 执行器

MySQL 通过分析器知道了我们要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

开始执行的时候，要先判断一下我们对这个表 T 有没有执行查询的权限，如果没有，就返回没有权限的错误，

```sql
select * from T where ID = 10
```

**对于没有索引的表**，执行流程是这样的：

1. 调用 InnoDB 引用接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中。
2. 调用引擎接口取 “下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中满足条件的行组成的记录集作为结果集返回给客户端。

到目前位置，这个语句就执行完成了。

**对于有索引的表**，执行的脱机差不多，第一次调用的是 ”取满足条件的第一行“ 这个接口，之后循环取 ”满足条件的下一行“ 这个接口，这些接口都是引擎中已经定义好的。













































































