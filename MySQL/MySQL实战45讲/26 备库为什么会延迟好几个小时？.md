# 26 | 备库为什么会延迟好几个小时？

在某些场景下，不论是偶发性的查询压力，还是备份，对备库延迟的影响一把你是分钟级别的，而且在备库恢复正常以后都能够追上来。

但是如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了几个小时级别。而且对于一个压力持续比较高的主库来说，备库很可能永远都追不上主库的节奏。



### **主备流程**

<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220324103604130.png" alt="image-20220324103604130" style="zoom:67%;" />



日志在备库上的执行，就是图中备库上 sql_thread 更新数据(DATA)的逻辑，如果使用单线程的话，就会导致备库应用日志不够快，造成主备延迟。

所有的多线程复制机制，都是要把上图中只有一个现车给的 sql_thread ，拆成多个线程，也就是符合下面的这个模型

<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220324104336491.png" alt="image-20220324104336491" style="zoom:67%;" />

上图中 coordinator 就是原来的 sql_thread，不过现在它不在直接更新数据库了，只负责读取中转日志和并发事务。真正更新日志的，变成了 worker 线程。

**问题1：**事务能不能按照轮询的方式分发给各个 worker，也就是第一个事务分给 worker_1，第二个事务分发给 worker_2 呢？

不可以的，可能会导致在主库和备库上的执行顺序相反，会出现主备不一致的问题。

**问题2：**同一个事务的多个更新语句，能不能分给不同的 worker 来执行呢？

不能。有可能破坏事务逻辑的隔离性



所以，coordinator 在分发的时候，需要满足以下两个基本要求：

1. 不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个 worker 中。
2. 同一个事务不能被拆开，必须放到同一个 worker 中。



### MySQL 5.5 版本并行复制策略

#### 按表分发策略

如果两个事务更新不同的表，他们就可以并行，因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。

如果有跨表的事务，还是要把两张表放在一起考虑。











































































































































































































































