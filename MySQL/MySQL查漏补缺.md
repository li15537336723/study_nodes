# WHERE 与 HAVING 有什么区别

WHERE 是一个约束声明，使用 WHERE 约束来自数据库的数据，WHERE 是在结果返回之前起作用的，WHERE 中不能使用聚合函数。

HAVING 是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在 HAVING 中可以使用聚合函数。另一方面，HAVING 子句中不能使用除了分组字段和聚合函数之外的其他字段



# MySQL调优

- **索引覆盖**

索引覆盖可以减少树的搜索次数，显著提升查询性能，因此使用索引覆盖是一个常用的性能优化手段

- 最左前缀

如果已经有了（a，b）这个联合索引后，一般就不需要单独在 a 上简历索引了。因此，**第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。**

- **索引下推**

在 MySQL5.6 之后引入索引下推，可以在索引遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表的次数。

![image-20220623161523530](https://lixianghong.oss-cn-beijing.aliyuncs.com/typore/image-20220623161523530.png)



# 怎么减少行锁对性能的影响

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。**这就是两阶段锁协议。**

如果我们的事务中需要锁多个行，要把最可能造成冲突，最可能影响并发度的锁尽量往后放

举例说明：

顾客A到电影城B买票，将会执行一下操作

> 1. 从顾客 A 账户中扣除电影票价
> 2. 给影院的账户余额增加这张电影票价
> 3. 记录一条交易日志

一共需要 **update** 两条记录，并 **insert** 一条记录，该三个语句在一个事务中。

假设又有顾客C到电影城B买票，那么这两个事务冲突的部分就是第二条语句了，因为他们要更新同一个影院账户的余额，需要修改同一行数据。

根据两阶段锁协议，不论怎么安排语句，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，把 2 安排在最后，比如按照 3，1，2这样的顺序，那么影院账户余额这一行的锁时间就最少。最大程度地减少了事务之间地锁等待，提升了并发度。



















