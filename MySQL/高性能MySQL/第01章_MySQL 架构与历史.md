# 第01章_MySQL 架构与历史

## 1. 并发控制

无论何止，知道有多个查询需要再同一时刻修改数据，都会产生并发控制的问题。

### 1.1 读写锁

**读**：就是对数据库进行**查询**的操作

**写**：对数据库进行**增删改**的操作

数据库中一般分为两种锁：共享锁（shared lock）和排他锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）

**锁的概念**：读锁是共享的，或者说是互相不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑。

## 1.2 表锁与行级锁

**表锁**是 MySQL 中最基本的策略锁，并且是开销最小的策略，它会将整张表都锁起来。当一个用户对该表进行写的操作的时候，另一个用户是不可以同时对该表也进行写的操作的。另外写锁的优先级要比读锁的优先级高一些。

**行级锁**可以最大程度的支持并发处理（同时也带来了最大的锁开销）

## 1.3 事务

事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。

### 1.3.1 ACID

ACID 表示原子性（atomicity），一致性（consistency），隔离性（isolation）和持久性（durability）。一个运行良好的事务处理系统，必须具备这些标准特征。

- 原子性（atomicity）

  一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

- 一致性（consistency）

  数据库总是从一个一致的状态转换到另一个一致性的状态

- 隔离性（isolation）

  通常来说，一个事务所作的修改在最终提交之前，其他事务是不可见的。

- 持久性（durability）

  一旦事务提交，则其所做的修改就会永久保存到数据库中。

### 1.3.2 隔离级别

四种隔离界别

READ UNCOMMITTED（未提交读）

READ COMMITTED（提交读）

REPEATABLE READ（可重复读）

SERIALIZABLE（可串行化）

### 1.3.3 死锁

死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

看下面两个事务同时处理 StockPrice 表：

**事务 1:**

```sql
START TRANSACTION;
UPDATE StockPrice SET `close` = 45.50 WHERE stock_id = 4 and date = '2020-05-01'
UPDATE StockPrice SET `close` = 19.80 WHERE stock_id = 3 and date = '2020-05-02'
COMMIT
```

**事务 2:**

```SQL
START TRANSACTION;
UPDATE StockPrice SET high = 20.12 WHERE stock_id = 3 and date = '2020-05-02'
UPDATE StockPrice SET high = 47.20 WHERE stock_id = 4 and date = '2020-05-01'
COMMIT
```

如果两个事务都执行第一条 UPDATE 语句，更新了一行数据，同时也锁定了该行数据，接着每个事务都尝试执行第二条 UPDATE 语句，却发现改行已经被对方锁定，然后两个事务都在等待对方释放锁，同时又持有对象需要的锁，则会陷入死循环。除非由外部因介入。

InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）







