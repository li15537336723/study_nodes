# 1 约束



## 1.1 什么是约束



约束对应的单词：constraint

在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性，有效性！！！

约束的作用就是为了保证：表中的数据有效！！

检查约束：check（mysql不支持，oracle支持）



## 1.2 约束包括那些



**重要的四个约束：**

非空：`not null`

独一无二：`unique`

主键：`primary key`

外键：`foreign key`



## 1.3 非空约束



```sql
DROP TABLE IF EXISTS t_vip
CREATE TABLE t_vip(
	id INT,
	NAME VARCHAR(255) NOT NULL
)
INSERT INTO t_vip(id, NAME) VALUES (1, 'zhangsan')
SELECT * FROM t_vip
```



小插曲：

xxx.sql 这种文件被称为 sql 脚本文件。sql 脚本文件中编写了大量的 sql 语句。我们执行 sql 脚本文件的时候，该文件中所有的sql 语句会全部执行

语法：

```sql
source D:\xx\xx\
```



## 1.4 唯一性约束

```sql
drop table if exists t_vip
create table t_vip(
	id int,
    name varchar(255) unique,
    email varchar(255)
)
insert into t-vip(id, name, email) values (1, 'zhangsan', '123@.com')
insert into t-vip(id, name, email) values (2, 'lisi', '123456@.com')
```



**新需求：name 和 email 两个字段==联合起来具有唯一性==**

```sql
drop table if exists t_vip
create table t_vip(
	id int,
    name varchar(255),
    email varchar(255),
    unique(name, email)
)
insert into t_vip values(1, 'lisi', '123.com')
insert into t_vip values(2, 'lisi', '123456.com')
```







## 1.5 主键约束 primary key



**主键约束的相关术语**

​	主键约束：就是一种约束

​	主键字段：该字段上添加了主键约束，这样的字段叫做：主键字段

​	主键值：主键字段中的每一个值都叫做：主键值

**什么是主键？有啥用？**

​	主键值是每一行记录的唯一表示

​	主键值是每一行记录的身份证号！！！

**==任何一张表都应该有主键，没有主键，表无效！！！==**



 **主键的特征：not null + unique (主键值不能是 null，同时也不能重复)**

```sql
create table t_vip(
	id int primary key,
    name varchar(255)
)
```



在 mysql 当中，有一种机制，可以帮助我们自动维护一个主键

```sql
drop table if exists t_vip
create table t_vip(
	id int primary key  auto_increment,
    name varchar(255)
)
```





# 2 存储引擎



## 2.1 什么是存储引擎



存储引擎是 mysql 中特有的一个术语，其他数据库中没有

存储引擎是一个表存储/组织数据的方式，不同的存储引擎，表存储数据的方式不同。



在建表的时候可以在最后小括号的 **")"** 的右边使用：

==ENGINE 来指定存储引擎==

==CHARSET 来指定这张表的字符编码方式。==

结论：

​	mysql 默认的==存储引擎是：InnoDB==

​	mysql 默认的==字符编码方式是：utf8==

```sql
create table t_product(
	id int primary key,
    name varchar(255)
)engine=InnoDB default charset = utf8
```



## 2.2 常用引擎

**MyISAM  存储引擎**

​	它管理的表具有以下特征

​		使用三个文件表示每个表：格式文件 —— 存储表结构的定义

​		数据文件——存储表行的内容

​		索引文件——存储表上的索引

**InnoDB 存储引擎**

​	这是 mysql 默认的存储引擎，同时也是一个重量级的存储引擎

​	InnoDB 支持事务，支持数据库崩溃后自动恢复机制

​	InnoDB 存储引擎最主要的特点是：非常安全

**MEMORY存储引擎**

​	



# 3 事务



## 3.1 什么是事务



一个事务就是一个完整的业务逻辑。

什么是一个完整的业务逻辑？

假设转账，从A账户向B账户中转账10000

将A账户的钱减去10000（update语句）

将B账户的钱加上10000（update语句）

这就是一个完整的业务逻辑

以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。这两个update 语句要求必须同时成功或者同时失败，这样才能保证钱是正确的



## 3.2 有关事务的 SQL



只有 DML 语句才会有事务这么一说，其他语句和事务无关

insert

delete

update

只有以上的三个语句和事务有关系，其他都没有关系，因为只有以上的三个语句是数据库表中数据进行增删改的。只要操作中一旦涉及道数据的增删改，那么就一定要考虑安全问题

数据安全第一位



## 3.3 了解事务

在做某件事的时候，需要多条DML语句共同联合起来才能完成，所以需要事务的存在。如果任何一件复杂的事都能一条 DML 语句搞定，那么事务则没有存在的价值了。

到底什么是事务？

​	本质上，事务就是多条 DML 语句同时成功，或者同时失败！

事务就是批量的DML语句同时成功同时失败



## 3.4 事务原理



事务是怎么做到多条 DML 语句同时成功和同时失败呢？

InnoDB 存储引擎：提供一组用来记录事务性活动的日志文件

事务开启了：

insert	....	insert	......	insert	.......	delete 	.........	update	......	update	......	update

事务结束了！

在事务的执行过程中，每一条DML的操作都会记录到 “事务性活动的日志文件” 中。在事务的执行过程中，我们可以提交事务，也可以回滚事务。

**提交事务：**

​	清空事务活动的日志文件，将数据全部彻底持久化到数据库表中。提交事务标志着，事务的结束，并且是一种全部成功的结束

**回滚事务：** 

​	将之前所有的 DML 操作全部撤销，并且清空事务性活动的日志文件，回滚事务标志着，事务的结束。并且是一种全部失败的结束



## 3.5 怎么提交事务，怎么回滚事务

提交事务：commit ：语句

回滚事务：rollback：语句 

事 

测试一下，在 mysql 当中默认的事务行为是怎么样的？

​	mysql 默认情况下是支持自动提交事务的。

自动提交：即每执行一条MDL语句，则提交一次！

这种自动提交实际上不符合我们的开发习惯，因为一个业务通常是需要多条 MDL 语句功能执行才能完成的，为了保证数据的安全性，必须要求同时成功之后再提交，所以不能执行一条就提交一条

**关闭自动提交的名令：`start transaction`**



## 3.6 事务特性



事务包括 4 个特性

**A：原子性**

​	说明事务是最小的工作单元

**B：一致性**

​	所有事物要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，以保证数据的一致性

**C：隔离性**

​	A事务和B事务之间具有一定的隔离

​	教室A和教室B之间有一道墙，这道墙就是隔离性

​	A事务在操作一张表的时候，另一个事务B也操作这张表 会怎么

**D：持久性**

​	事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据保存到硬盘上



## 3.7 事务隔离性



A教室和B教室中间有一道墙，这道墙可以很厚，也可以很薄。这就是事务的隔离级别。这道墙越厚说明隔离级别越高。

事务和事务之间的隔离级别有 4 个级别

**读未提交：read uncommitted（最低的隔离级别）**

​	什么是读未提交？

​		事务A可以读取到事务B未提交的数据

​	这种隔离级别存在的问题就是：

​		脏读现象！

​		我们称读到了脏数据

​	这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步

**读已提交：read committed**

`什么是读已提交？`

​	事务A只能读取到事务B提交之后的数据。

`这种隔离级别解决了什么问题？`

​	解决了脏读的现象

`这种隔离级别存在什么问题？`

​	不可重复读取数据。

​	什么是不可重复读取数据呢？

​		在事务开启后，第一次读到的数据是 3 条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是4条，3不等于4称为不可重复读取。

**可重复读：repeatable read**

​	`什么是可重复读取？`

​		事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务 B 将数据已经修改，并且提交了，事务 A读取到的数据还是没有发生改变，这就是可重复读。

`可重复读解决了什么问题？`

​		解决了不可重复读取数据

`可重复读存在什么问题？`

​		可以会出现幻影读

​		每一次读取到的数据都是幻想，不够真实！

**==mysql 中默认的事务隔离级别就是这个！！！！！==**



**序列化/串行化：serializable（最高的隔离级别）**

​	这是最高隔离级别，效率最低。解决了所有的问题

​	这种隔离级别表示事务排队，不能并发！synchronized，线程同步（事务同步）

每一次读取到的数据都是最真实的，并且效率最高





# 4 索引（index）



## 4.1 什么是索引 ?



索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。一张表的又给字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。

对于一本字典来说，查找某个汉字有两种方式：

***第一种方式：***一页一页挨着找，知道找到为止，这种查找方式属于全字典扫描，效率比较低

***第二种方式：***先通过目录（索引）去定位一个大概的位置，然后直接定位到这个位置，做局域性扫描，缩小扫描范围，快速的查找，这种查找方式属于通过索引检索，效率较高



一般条件查询

```sql
select * from emp where no = 5
```

上面这条SQL语句会去 no 字段上扫描，因为我们的条件是在 no 上加的

如果no 字段上没有添加索引（目录），或者说没有给 no 字段创建索引， MySQL 会进行全扫描，会将 name 字段上的每一个值都对比一遍。效率比较低

MySQL 在查询方面主要就是两种方式：

​	第一种方式：全表扫描

​	第二种方式：根据索引检索

注意：

​	在实际中，汉语字典目录排序按照 abcdef... 排序，因为只有拍虚了才会有区间查找（缩小查找范围）

​	在 mysq 数据库当中索引也是需要排序的，并且这个索引的排序和 TreeSet 数据结构相同。TreeSet（TreeSetMap）第层是一个自平衡的二叉树！在mysql当中索引是一个 B-Tree 数据结构





## 4.2 索引的实现原理



![image-20210719170852180](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210719170852180.png)



**提醒1：**在任何数据库当中的主键上都会自动添加索引对象，id 字段上自动有索引，因为 id 是 primary key。另外在 mysql 当中，一个字段上如果有 unique 约束的化，也会自动创建索引对象。

**提醒2：**在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号

**提醒3：**在mysql 当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在 MyISAM 存储引擎中，索引存储在一个 .MYI 文件中。在 InnoDB 存储引擎中索引存储在一个逻辑名称叫做 tablespace 的当中。在 MEMORY 存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在 MySQL 当中都是一个树的形式存在。（自平衡二叉树：B-Tree）



## 4.3 主键 unique字段索引

在MySQL 中，主键上，以及 unique 字段上都会自动添加索引

什么条件下，我们会考虑给字段添加索引？

条件1：数据量庞大

条件2：该字段经常出现在 where 后面，以条件的形式存在，也就是说这个字段总是被扫描

条件3：该字段很少的DML操作。因为（DML之后，索引需要重新排序）

建议不要随意添加索引，因为索引也是需要维护的，太多的化反而会降低系统额性能。建议通过主键查询，建议通过 unique 约束的字段进行查询，效率是比较高的。



## 4.4 索引创建/删除



**创建索引：**

```sql
create index emp_ename_index on emp(ename)
```

给 emp 表的 ename 字段添加索引，起名：emp_ename_index

**删除索引：**

```sql
drop index emp_ename_index on emp
```

将 emp 表上的 emp_ename_index 索引对象删除



## 4.5 检验是否使用索引

```sql
explain select * from emp where ename = "KING"
```

![image-20210720084427991](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210720084427991.png)



## 4.6 索引失效

```sql
select * from emp where ename like '%T'
```

ename 上即使添加了索引，也不会走索引，为什么？

​	原因是因为模糊匹配当中以 “%” 开头了

​	尽量避免模糊查询的时候以 “%” 开始

​	这是一种优化的手段/策略







## 4.7 索引优化

索引是各种数据库进行优化的重要手段。优化的时候优先考虑因素就是索引。索引在数据库当中分了很多类。

单一索引：一个字段闪光添加索引

复合索引：两个字段或者更多的字段上添加索引

主键索引：主键上添加索引

唯一性索引：具有unique约束的字段上添加索引

.......

注意：唯一性比较弱的字段上索引用处不大



# 5 DBA

重点掌握：

​	数据的导入导出名令

**数据导入：**

​	source *sql文件路径*

**数据导出：**

**==注意：==** 在 windows 的 dos 名令窗口中：

![image-20210720101106150](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210720101106150.png)

导出指定的表：

​	![image-20210720101125427](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210720101125427.png)









# 6 三大范式



## 6.1 什么是范式



数据库表的设计依据，教你怎么进行数据库表的设计



## 6.2 各范式说明



**第一范式：**要求任何一张表必须有主键，每一个字段原子性不可再分

**第二范式：**建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖

**第三范式：**建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖



设计数据库表的时候，按以上要求的范式进行，可以避免表中的数据冗余，空间浪费



## 6.3 第一范式

最核心，最重要的范式，所有表的设计都需要满足

**==必须有一个主键，并且每个字段都是原子性不可再分==**



## 6.4 第二范式

建立在第一范式的基础上，要求所有非主键字段必须完全依赖主键，不要产生部份依赖。



## 6.5 第三范式

建立在第二范式的基础上，要求所有非主键字段必须直接以来逐渐，不要有传递依赖



















