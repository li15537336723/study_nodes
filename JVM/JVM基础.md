# JVM 基础

## 一、类加载过程

- 加载
- 验证
- 准备
- 解析
- 初始化
- 使用
- 卸载



### 1.1 加载

主要完成以下三步：

1. 通过全类名获取定义此类的二进制字节流
2. 通过字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 `class` 对象，作为方法区这些数据的访问入口

**数组类型不通过类加载器创建，它由 Java 虚拟机直接创建**



### 1.2 验证

**文件格式验证：**验证字节流是否符合 Class 文件格式的规范

**元数据验证：**对字节码描述的信息进行语义分析

**字节码验证：**最复杂的一个阶段。通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。

**符号引用验证：**确保解析动作能正确执行



### 1.3 准备

准备阶段是正式为类变量（也称静态变量，`static` 关键字修饰的）分配内存并初始化（对应数据类型的默认初始值，如 0，0L，null、false等）

也就是说，假如有这样一段代码：

```java
public String chenmo = "小李";
public static String wanger = "王二";
public static final String cmower = "沉默王二";
```

chenmo 不会被分配内存，而 wanger 会，但 wanger 的初始值不是 ==王二== 而是 `null`

需要注意的是，`static final` 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 cmower 在准备阶段的值为 ==沉默王二== 而不是 `null`



### 1.4 解析

该阶段将常量池中的符号引用转化为直接引用

**符号引用：**以一组符号来描述所引用的目标。比如: `com.Wanger` 类引用了 `com.Chenmo` 类，编译时 Wanger 类并不知道 Chenmo 类的实际地址，因此只能使用符号 `com.Chenmo`

**直接引用：**通过对符号引用进行解析，找到引用的实际内存地址



### 1.5 初始化

初始化阶段是执行类构造器方法的过程

```java
String cmower = new String("沉默王二");
```

上面这段代码使用了 `new` 关键字来实例化一个字符串对象，那么这个时候，就会调用 String 类的构造方法对 cmower 进行实例化。



## 二、类加载器

对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在 JVM 中的唯一性。也就是说，如果两个类的加载器不同，即使两个类来源同一字节码文件，那这个类就必定不相等

**Java类加载器可以分为三种**

1. 启动类加载器：加载 `jre/lib` 包下面的 jar 文件，比如常见的 rt.jar。
2. 扩展类加载器：加载 `jre/lib/ext` 包下面的 jar 文件
3. 应用类加载器：根据程序的类路径来加载 Java 类























