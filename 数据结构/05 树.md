# 树

### 1、树的定义

树是 n 个结点的有限集，它或为空树，或为非空树，对于非空树 T：

（1）有且仅有一个称之为根的结点

（2）除根节点以外的其余结点可分为 m 个互不相交的有限集T1，T2，，，，Tm，其中每一个集合本身又是一颗树，并且称为根的子树



### 3、二叉树的定义

（1）有且仅有一个称之为根的结点；

（2）除根节点以外的其余结点分为两个互不相交的子集T1和T2，分别称为 T 的左子树和右子树，且 T1 和 T2 本身又都是二叉树。

二叉树基本特点：

- 结点的度小于等于2（最多有 2 颗子树）
- 有序树（子树有序，不能颠倒）

### 4、二叉树的性质

性质1：在二叉树的第 **i** 层上至多有 **2^(i-1)** 个结点

性质2：深度为 k 的二叉树至多有 **2^k - 1** 个结点

性质3：对于任何一颗二叉树，若度为 **2** 的结点数量有 **N2** 个，则叶子节点为**N0** 必定为 **N2 + 1.(N0 = N2 + 1)**

性质4：具有 n 个结点的完全二叉树的深度必为 <img src="C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610105822063.png" alt="image-20210610105822063" style="zoom: 33%;" />

性质5：对完全二叉树，按层序从上至下，每层从左至右对结点编号，对于任一结点 i (1 <= i <= n)有：

- 若 i = 1，则结点 i 为根节点，无双亲；若 i > 1, 则其双亲为 <img src="C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610110203532.png" alt="image-20210610110203532" style="zoom: 33%;" />
- 若 2i > n，则结点 i 无左孩子，否则其左孩子必为 2i；
- 若 2i + 1 > n，则结点 i 无右孩子，否则其右孩子 编号必为 2i + 1。





### 5、特殊形态的二叉树

**满二叉树：**一颗深度为 k

且有 2^k - 1 个结点的二叉树

**满二叉树的结点个数必为奇数**

==（特点：每层都 “充满” 了结点）==



**完全二叉树：**深度为 K 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点==一一对应==



**完全二叉树特点分析** 

![image-20210610105243425](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610105243425.png)



高为 h 的完全二叉树

- 前 h - 1 层结点均是 “满的”
- 第 h 层可能不满，且结点靠左集中
- 叶子只可能出现在最后两层，且最后一层至少缺少 2 个结点时，倒数第二层才会有叶子节点。
- 度为 1 的结点只能有 0 个或 1 个，若有，只能是最后一个叶子的双亲，且有左孩子无有孩子
- ==完全二叉树上的叶子节点树为 <img src="C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610112539726.png" alt="image-20210610112539726" style="zoom:25%;" />向上取整==





#### 满二叉树和完全二叉树的区别

满二叉树是结点一个也不少的树，而完全二叉树虽然前 n-1 层是满的，但最底层却允许在右边缺少连续若干个结点

==**满二叉树是完全二叉树的一个特例**==





### 重要结论

若二叉树中各结点的值均不相同，则：

- 由二叉树的前序序列和中序序列，或由其后序序列和中序序列均能唯一的确定一颗二叉树

方法：

- 先序（序列第一个），后序（序列最后一个）确定根

- 中序分左右

  ​	循环以上两步，直至序列处理结束

- 由前序序列和后序序列却不可以唯一确定一棵二叉树（结点只有一棵子树时）

在 n 个结点的二叉链表中，有 `n+1` 个空指针域，有 `n-1` 个非空指针域





线索化二叉树遍历

- 若结点无左孩子，其 lchild 指向遍历序列里直接前驱
- 若节点无右孩子，其 rchild 执行遍历序列里直接后继



树和森林与二叉树的转换

### 1、树转化为二叉树

方法：利用树的左孩子——右兄弟表示法

![image-20210610161750042](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610161750042.png)



#### 兄弟相连，长兄为父，孩子靠左，兄弟靠右



### 2、二叉树转换为树

方法：把二叉树中所有的右孩子变为兄弟

![image-20210610162009842](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610162009842.png)



#### 3、森林转化为二叉树

1）各树先各自转换为 二叉树

2）从第二棵树开始，每棵二叉树依次连到前一棵二叉树根结点的右子树上。

![image-20210610164345289](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610164345289.png)



### 4、二叉树转换为森林

方法：把根的右子树线断开变为若干棵二叉树，再将各个二叉树转变为树。





### 数和森林的遍历

遍历方式有两种：**深度遍历（先序，中序，后序）广度遍历（层次）**![image-20210610164842888](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610164842888.png)



![image-20210610165234970](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610165234970.png)

**==结论：==** 

- 树的先序遍历二法相同
- 树的**后序**遍历相当于对应二叉树的**中序**遍历
- 树没有中序遍历，因为子树无左右之分





### 森林的遍历

先序遍历

- 若森林为空，返回

- 访问森林中第一棵树的根节点

- 先序遍历第一棵树中根结点的子树森林

- 先序遍历除去第一棵树之后剩余的树够成的森林

  ==即：依次先序遍历森林中的每一棵树==

中序遍历

- 若森林为空，返回；

- 中序遍历森林中第一棵树的根节点的子树森林

- 访问第一棵树的根节点

- 中序遍历除去第一棵树之后剩余的树够成的森林

  ==即：依次后序遍历森林中的每一棵树==

  ![image-20210610173830287](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610173830287.png)



![image-20210610174009405](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610174009405.png)



## 哈夫曼树

![image-20210610174928079](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210610174928079.png)

### 基本概念：

（1）路径：由一结点到另一结点间的分支所构成。

（2）路径长度：路径上的分支数目。 ==a—>d 的路径长度 = 2==

（3）树的路径长度：从树根到**每一结点**的路径长度之和	===10==

（4）权：赋予某个实体的一个量，是对实体的属性的数值化描述，若树的结点

（5）结点的带权路径长度：结点到根的路径长度与结点上权值的乘积。==d的带权路径长度 = 7*2 = 14==

（6）树的带权路径长度：树中**所有叶子节点**的带权路径长度之和	**WPL = W * L**

（7）赫夫曼树：最优二叉树，带权路径长度最小的树



#### 哈夫曼树的特点

- 权值大的结点到根节点的路径长度短
- 权值小的结点到根节点的路径程度长

##### 基本思想

权值大的结点用最短路径，权值小的结点用长路径

##### 哈夫曼树特点

- 哈夫曼编码树中没有度为1的结点
- 若给定 n 个权值（n 个叶子结点），则哈夫曼树的总结点数为 2n - 1;
- 哈夫曼树的高度不超过 n。

##### 

##### 前缀编码：任一字符的编码都不是另一字符编码的前缀

如：字符 `a，b` 的编码分别为 `0，01` 则 a 的编码是 b 的编码的前缀，该编码不是前缀编码。

##### 哈夫曼编码

对一棵具有 n 个叶子的哈夫曼树，对每个左分支赋予 0，右分支赋予 1，则从根到每个叶子的路径上，分别够成一个二进制串，该二进制串称为哈夫曼编码。

**==进行哈夫曼编码，先建哈夫曼树==**

**==哈夫曼编码是前缀编码，且是最优前缀编码==**


