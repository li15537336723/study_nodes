## 1、解释 Java 中的锁升级

1. 检查Mark Word 里面的线程ID，如果是，表示当前线程处于偏向锁
2. 如果不是，将使用CAS将当前线程的ID替换Mard Word，如果成功，则表示当前线程获取偏向锁，置偏向锁的标志位为1
3. 如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。
4. 当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，但前线程获得锁
5. 如果失败，则通过自旋来尝试继续获得锁。
6. 如果自旋成功，而仍然处于轻量级锁。
7. 自旋失败，锁升级为重量级锁。

## 2、解释可重入锁的概念及原理

**概念：**可重入锁意味着：若一个程序或子程序可以“在任意时刻被[中断](https://so.csdn.net/so/search?q=中断&spm=1001.2101.3001.7020)然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”

**原理**：每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。



## 3、解释自旋锁的概念及原理

与互斥锁相似，基本作用是用于线程（进程）之间的同步。与普通锁不同的是，一个线程A在获得普通锁后，如果再有线程B试图获取锁，那么这个线程B将会挂起（阻塞）如果两个线程资源竞争不是特别激烈，而处理器阻塞一个线程引起的线程上下文的切换的代价高于等待资源的代价的时候（锁的已保持者保持锁时间比较短），那么线程B可以不放弃CPU时间片，而是在“原地”忙等，直到锁的持有者释放了该锁，这就是自旋锁的原理，可见自旋锁是一种非阻塞锁。



## 4、voliate关键字的使用场景及作用

https://github.com/duktig666/knowledge/blob/main/java/thread/volatile%E6%80%BB%E7%BB%93.md



## 5、进程间如何通信

1、管道( pipe )
管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2、有名管道（FIFO）
名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3、信号
用于通知接收进程某个事件已经发生，主要作为进程间以及同一进程不同线程之间的同步手段。
4、信号量
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。
5、消息队列
消息队列是消息的链表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
6、共享内存
共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。
特点：
共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
因为多个进程可以同时操作，所以需要进行同步。
信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。



## 6、线程间通信？

1）使用 volatile 关键字来实现线程间互相通信是使用共享内存的思想，以上就是多个线程同时监听一个变量，当这个变量发生变化的时候，线程能够感知并执行相应的业务。这也是最简单的实现方案

2）使用 Object 类的 `wait() / notify()`

`wait()、notify()、notifyAll()`，他们是多线程的基础

**需要注意的是 wait/notify 必须配合 synchronized 使用，wait 方法释放锁，nitify 方法不释放锁。**

- wait()、notify()、notifyAll() 调用的前提都是获得了对象的锁（也可称为对象监视器）
- 调用 wait() 方法后线程会释放锁，进入 `WAITING` 状态，该线程也会被移动到等待队列中
- 调用 notify() 方法会将等待队列中的线程移动到同步队列中，线程状态也会更新为 `BLOCKED`
- 从 wait() 方法返回的前提是调用 notify() 方法的线程释放锁，wait() 方法的线程获得锁

3）使用 JUC 工具类 CountDownLatch

concurrent 包下提供了很多并发编程相关的工具类，简化了并发编程代码的书写，CountDownLatch 基于 AQS 框架，相当于也是维护了一个线程间共享变量 state

4）使用 ReenrantLock 结合 Condition

https://blog.csdn.net/qq_21267357/article/details/126134967

5）基本 LockSupport 实现线程间的阻塞和唤醒

LockSupport 是一种非常灵活的实现线程间阻塞和唤醒的工具，使用它不用关注是等待线程还是唤醒线程先运行，但是得知道线程的名字

































































