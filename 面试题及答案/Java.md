## 1、NIO、BIO、AIO的区别

NIO（同步非阻塞）：使用**同步非阻塞的 I/O 模型**，提供了 Channel，Selector，Buffer 等抽象，NIO 中的N可以理解为 Non-blocking，不是单纯的 New。它支持面向缓冲的，基于通道的 I/O 操作方法，**NIO提供了与传统BIO模型中的 Socket 和 ServerScoket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式**。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载，低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载，高并发的（网络）应用，应使 NIO 的非阻塞模式来开发

BIO（同步阻塞）：数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高的情况下，这种模式是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量

AIO：在 Java7 中引入了 NIO 的改进版 NIO 2，它是**异步非阻塞的 IO 模型**。异步IO是基于 **事件和回调机制** 实现的，也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身时同步的。

## 2、Collection 有什么子接口

**Collection 接口是 Set，Queue，List 的父接口**

**Coolection 接口的方法**

- boolean isEmpty()：判断集合是否为空
- Iterator iterator()：返回一个 Iterator 对象，可以用来遍历集合中的元素
- int size()：返回集合中元素的数目
- toArray()：返回一个包含集合中所有元素的数组



## 3、Hash Map并发写会有什么问题？

- 数据丢失问题：扩容过程中形成环形链表，在环形链表之后的元素不会被遍历到，造成丢失
- 死循环：并发扩容形成环形链表，get(key)就会发生死循环问题



## 4、HashCode 与 equals关系

hashcode：说来了，简单的就看做一个函数，但是该函数有可能出现：对于某个 x 值，存在不止一个 y 值与之对应。这种情况就叫 **哈希碰撞**

那么：

1. 如果 hashCode 相等，两个对象不一定是同一个对象（比如，两个对象的哈希值出现了 哈希碰撞现象）这就证明了 hashCode 相同的两个对象，未必满足 equals；
2. 如果两个对象 equals，也就是 hash 值相同，那么它们的 hashCode 应该是相同的



## 5、深拷贝与浅拷贝

浅拷贝：只是拷贝了源对象的地址，所以当源对象发生改变时，拷贝的对象值也会对应发生改变

深拷贝：拷贝了原来对象的所有值，而不是地址，所以拷贝对象中的不会随着源对象中的值的改变而改变



## 6、RuntimeException Exception Error 的区别

1. 首先异常类的父类是 Throwable
2. Throwable 类有两大子类：Error，Exception
3. Error 错误：
   1. 程序在运行过程中发生了非常严重的错误，并且该错误是不可恢复的
   2. 由于类错误是 jvm 层的错误，因此，这种错误会导致程序的终止运行
   3. 编译器不会检查程序中是否有错误
4. Exception 异常
   1. 异常是可以恢复的
   2. **Exception 可以分为 CheckedException** 和 RuntimeException
   3. CheckedException（检查异常）
      1. 最常见的就是 IO 异常和 SQL 异常，这种异常通常发生在编译阶段
      2. 编译器会强制要求程序员去捕获此类异常
      3. 异常的发生不会导致程序出错
      4. 对异常处理之后程序还能继续运行
   4. RuntimeException（运行时异常）
      1. 程序在运行时发生的异常
      2. 编译器没有去强制对其进行捕获并处理
      3. 如果不对这类异常进行处理，JVM 将会处理：例如：空指针
      4. 出现运行时异常，系统会将异常向上抛，直到遇到处理代码为止

**finally 中的代码什么时候执行？**

1. 不管 try 中是否发生异常，finally 都会执行
2. try-finally，try-catch-finally 代码中的 return 语句优先级高于代码外面的，也就是 try-finally，try-catch-finally代码块中的 return 将覆盖其他的 return 语句



## 7、lambda 表达式中使用外部变量，为什么要 final？

- 外层局部变量是通过传参的方式，使其内部能时用到这个局部变量，是值传递
- lambda 表达式只是定义了抽象方法的实现，不会被立即调用
- lambda 表达式引用的局部变量，如果被外层代码修改后，lambda 表达式内部无法同步，会导致数据不一致
- 同样，在lambda 表达式内部，也是无法修改局部变量，只能调用局部变量



## 8、为什么重写 equals 时必须重写 hashCode 方法？

如果两个对象相同，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的。**因此，equals 方法被覆盖过，则 `hashcode` 方法也必须被覆盖**。



## 9、ArrayList

**查找 ArrayList 中的元素**

如果要正序查找，可以使用 `indexOf()`方法，如果倒叙查找一个元素，可以使用 `lastIndexOf()` 方法

==contains() 方法==：该方法调用的方法就是 indexOf() 方法

```java
public boolean contains(Object o) {
    return indexOf(o) >= 0;
}
```

**增删改的时间复杂度**

1. `get(int index)`：访问一个元素的时间复杂度为 O(1)；
2. 默认添加一个元素（调用`add()` 方法时）的时间复杂度为 O(1)，因为直接添加到数组末尾的，但需要考虑扩容
3. 删除一个元素（调用`remove(Object)`方法时）的时间复杂度为 O(n)，因为要遍历列表。使用下标删除元素时，要考虑到数组的移动和复制所消耗的时间
4. 查找又给未排序的列表时间复杂度为 O(n)，因为要遍历列表；



## 10、LinkedList

**增**

`add("测试新增")`：在双向链表的最后添加数据

**删**

- `remove()`：删除第一个节点
- `remove(int)`：删除指定位置的节点
- `remove(Object)`：删除指定元素的节点
- `removeFirst()`：删除第一个节点
- `removeLast()`：删除最后一个节点

**改**

可以调用 `set()` 方法来更新元素

`list.set(0,"修改的数据")`，再修改时，首先会判断要修改的下标是在整个链表的前半截还是后半截，如果是前半截就重下标 0 开始遍历，如果是后半截就从最后一位开始遍历

**查**

- `idnexOf(Object)`：查找某个元素所在的位置
- `get(int)`：查找某个位置上的元素

- `getFirst()`：获取第一个元素
- `getLast()`：获取最后一个元素
- `poll() 和 pollFirst()`：删除并返回第一个元素
- `pollLast()`：方法用于删除并返回最后一个元素
- `peekFirst()`：方法用于返回但不删除第一个元素



## 11、HashMap 在多线程下会出现什么问题

问题：

1. 多线程扩容会死循环
2. 多线程下 put 会导致元素丢失
3. put 和 get 并发时会导致 get 到 null

问题描述：

1. 在扩容的时候，两个线程有可能会将会在同一位置上的新元素被放在链表的头部
2. 在多线程同时执行 put 操作时，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，导致元素丢失
3. 线程 A 执行put时，因为元素个数超出阈值而出现扩容，线程 B 此时执行 get，有可能导致这个问题



## 12、HashMap的遍历方式

1）迭代器



















































































































