# @Autowired 与 @Resource 的区别

**Autowired**

1、@Autowired是Spring自带的注解，通过AutowiredAnnotationBeanPostProcessor 类实现的依赖注入

2、@Autowired可以作用在CONSTRUCTOR（构造）、METHOD（方法）、PARAMETER（方法参数）、FIELD（字段）、ANNOTATION_TYPE（注解）

3、@Autowired默认是根据类型（byType ）进行自动装配的

**resource**

1、@Resource是JSR250规范的实现，在javax.annotation包下

2、@Resource可以作用TYPE(接口，类，枚举，注解)、FIELD（字段，枚举的常量）、METHOD上（方法）

3、@Resource是默认根据属性名称进行自动装配的



# IOC 和 DI 的关系

控制反转是通过 依赖注入实现的，它们是同一个概念的不同角度描述。通俗来说就是 IOC 设计思想，DI 是实现方式

依赖注入：由容器动态的将某个依赖关系注入到组件之中。它是为了提升组件重用的频率，提供一个灵活、可扩展的平台，通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，有谁实现

- **谁依赖于谁？**

  应用程序依赖于 IOC 容器

- **为什么需要依赖？**

  应用程序需要 IOC 容器来提供对象需要的外部资源

- **谁注入了谁？**

  IOC 容器注入应用程序某个对象，应用程序依赖的对象

**IOC 配置的三种方式**

1. xml 配置
2. Java 配置
3. 注解配置

**依赖注入的三种方式**

1. setter 注入
2. 构造函数注入
3. 注解注入



# AOP 原理

AOP：面向切面编程，它的目标是解耦，就是将分散在各个业务逻辑代码中相同的代码通过**横向切割**的方式抽取到一个独立的模块中！



基本概念，是什么

应用场景，用来干什么

实现原理



# IOC 原理

思想：IOC称为控制反转，即谁控制了谁，谁反转了谁。传统调用者是主动的一方，它需要什么资源就new资源。在spring应用中，IOC容器掌握者主动权，调用者变成了被动的一方，被动的等待着IOC创建它所需要的对象（bean）
在这个过程中，职责层面发生了控制权的反转，把原本调用者通过代码实现对象的创建，反转给IOC容器来帮忙实现，因此将这个过程称为Spring的控制反转。
实现：Spring通过通过一组配置文件描述Bean和Bean之间的依赖关系，利用java语言的反射功能来实例化Bean并建立Bean之间的依赖关系。Spring IOC在完成这些底层工作的基础上，还提供了Bean实例缓存、生命周期管理、Bean实例代理、事件发布、资源装载等高级服务。

源码解读：读取配置文件，加载到BeanDefinition，最终装载到beanFactory的过程

我们知道Spring是通过一组配置文件（xml，class，也可以是json等）的形式来生命bean之间的依赖关系的，中间肯定是需要通过 读取配置文件 --> 解析配置文件  --> 加载配置文件的bean到`BeanDefinition`，然后在交给`beanFactory`供后续创建bean来使用。



既然是容器，我们所熟悉的容器，他有 map，list，set，通过看spring源码可以直到，它所用的是map 容器，在创建对象的时候我们可以通过 XML 文件，注解来进行创建，不管是XML 还是注解都是用来生成对象的，那么我们需要想的是 xml 和注解里面到底定义的是什么？就是 bean 的定义信息，即 beandefinition，当加载解析完之后会放入到 IOC 容器中，但是它放入的并不是 xml 文件，而是解析之后的信息转化为对象。不同的文件需要不同的解析工具，所以还需要一个抽象层，这个抽象层就是 beanDefinitionReader，专门为了一个读取工作



# Spring 循环依赖的相关问题

首先我们需要说明的是，Spring 只是解决了单例模式下循环依赖的循环问题；Spring 为了解决到哪里的循环依赖问题，使用了 三级缓存

```java
/** Cache of singleton objects: bean name --> bean instance */
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);
 
/** Cache of early singleton objects: bean name --> bean instance */
private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);

/** Cache of singleton factories: bean name --> ObjectFactory */
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);
```



- **第一层缓存（singletonObjects）**：单例对象缓存池，已经实例化并且属性赋值，这里的对象是**成熟对象**
- **第二层缓存（earlySingletonObjects）**：单例对象缓存池，已经实例化但尚且未属性赋值，这里的对象是**半成品对象**
- **第三层缓存（singletonFactories）**：单例工厂的缓存



**Spring 为什么不能解决构造器的循环依赖？**

构造器注入形成的循环依赖：也就是 beanB 需要在  beanA 的构造函数中完成初始化，beanA 也需要在 beanB 的构造函数中完成初始化，这种情况的结果就是两个 bean 都不能完成初始化，循环依赖难以解决。

Spring 解决循环依赖主要是依赖三级缓存，但是**在调用构造方法之前还未将其放入三级缓存之中**，因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的 Bean，因此不能解决



**Spring 为什么不能解决 prototype 作用域循环依赖？**

这种循环依赖同样无法解决，因为 Spring 不会缓存 `prototype` 作用域的 bean，而 spring 中循环依赖的解决正是通过缓存来是实现的



**Spring 为什么不能解决多例的循环依赖？**

多实例 Bean 是每次调用一次 getBean 都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖



## 如果只有一个 map 结构，可以解决循环依赖嘛？

理论上来说是可以的，但是不优雅，当一级缓存和二级缓存合并之后，就意味着成品对象和半成品对象放到了一起，而半成品对象是不能暴露使用的，否则会出抱空指针异常，也就意味着需要通过一个标识来区分成品和半成品，同时一个容器的 bean 的名字是唯一的，所以只能再 value 中添加，也就是说在 value 中要加一个标识位，标识到底是半成品还是成品，那么每一次判断的时候都需要取出来，判断，很麻烦，所以可以做，但是不优雅

## 如果只有两个map 结构，可以解决循环依赖嘛？

理论上可以，但是有前提条件：当循环依赖的对象不需要创建代理对象的时候可以使用二级缓存解决问题，但是一旦涉及到动态代理的创建，那么二级缓存解决不了

## 为什么必须要用三级缓存在解决循环依赖？三级缓存是如何解决循环依赖问题的？

**《1》创建代理对象的时候是否需要创建原始对象？**

需要，因为 bean 的声明周期是固定的，每次在对象创建的时候必须要先创建出原始对象

**《2》同一个容器中能同时存在同名的不同对象嘛？**

不能

**《3》如果同时存在了原始对象和代理对象，怎么办？**

当对外暴露的时候因该使用代理对象，覆盖原始对象

**《4》为什么加了一个三级缓存就可以解决这个问题了？**

在整个 bean 的生命周期中，bean 对象的属性赋值（populateBean）在前执行，而 bean 动态代理对象（BeanPostProcessor 的后置处理方法）的创建在后执行

按照正常流程，先进行对象属性的赋值，而对象属性的赋值过程引用的都是原始对象，当赋值完成之后才会进行代理对象的创建，那么此时引用的对象必然不是最终版本的 bean 对象

**《5》如果想解决这个问题的话，怎么办？**

需要将代理对象的创建过程前置，也就是说在进行对象的属性赋值的时候，在设置具体的值之前，必须要唯一性的确定出到底是代理对象还是原始对象

**《6》为什么要用 lambda 表达式呢？**

因为在方法调用的时候 lambda 表达式并不会立即执行，在设置值具体的前一个步骤，回调即可，就可以唯一的确定好是用代理对象还是代理对象了

## 既然Spring中提供了循环依赖方案，为什么在写业务代码的时候还是会出现循环依赖？

Spring 是一个跟业务无关的框架，他只是提供了一个预防此种情况的循环依赖问题的解决方案，但是并不是所有的循环依赖问题都可以通过此方法解决，就跟我们写业务代码的异常一样，你可以写异常处理机制来预防一部分异常情况，但是不能解决所有的异常情况



# 说一下 BeanFactory 和 factoryBean 的区别

它们两个都是接口，都是用来进行对象的实例化操作的

**区别点：**

BeanFactory 中创建的对象都必须要严格的遵循 bean 的生命周期，属于标准化的流水线工作流程

FactoryBean 提供了一种私人定制的创建对象的方式，用户在创建某些对象的时候可以按照自己喜欢的方式来创建，并且能够被容器所管理

getObject：按照用户自定义的方式创建对象

getObjectType：返回创建对象的类型

Singleton：判断是否单例













































