# 1、Java中的锁

![img](https://cdn.nlark.com/yuque/0/2022/png/8413640/1666251621206-c50c2c8a-d760-461c-b5ea-e63a20773e90.png)



https://www.cnblogs.com/jyroy/p/11365935.html



# 2、lock 锁有哪些实现

ReentrantLock 可重入锁

ReadLock 读锁

WriteLock 写锁

ReentrantReadWriteLock 读写锁



# 3、Java中的并发容器

1）**ConCurrentHashMap**

底层依然是哈希表，Java7和Java8中的差异较大，Java7中采用分段锁来减少锁的竞争，JAVA 8中放弃了分段锁，采用CAS（一种乐观锁），同时为了防止哈希冲突严重时退化成链表（冲突时会在该位置生成一个链表，哈希值相同的对象就链在一起），会在链表长度达到阈值（8）后转换成红黑树（比起链表，树的查询效率更稳定）

**2）CopyOnWriteArrayList**

底层结构是数组，读操作不加锁因此适用于读多写少的场景

**3）CopyOnWriteArraySet**

基于 CopyOnWriteArrayList 实现，底层也是数组，意味着每次add都要遍历整个集合才能知道是否存在，不存在时需要插入

**4）ConCurrentLinkedQueue （并发队列，基于链表）**

基于链表实现的并发队列，使用CAS来保证线程安全，数据结构是链表

**5）Array BlockingQueue （阻塞队列，基于数组）**

基于数组实现的阻塞队列，构造时必须指定数组大小，给里面放东西时，如果数组满了会阻塞直到有位置，ReentrantLock 保证线程安全



# 4、实现的分布式锁

## 4.1 Zookeeper 方式

基于zookeeper临时有序节点可以实现的分布式锁。

**缺点：**

（1）性能上可能并没有缓存服务那么高，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上。

（2）zookeeper的并发安全问题：因为可能存在网络抖动，客户端和ZK集群的session连接断了，zk集群以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。

[
](https://blog.csdn.net/m0_67645544/article/details/124768505)

## 4.2 Redis 方式

setIfAbsent() 命令

这个命令中有几个参数

```java
stringRedisTemplate.opsForValue().setIfAbsent(lockKey, requestId, 30, TimeUnit.SECONDS);
```

第一个参数为 key，我们使用 key 来当锁，因为 key 是唯一的

第二个为 value，这里写的是锁竞争者的 id，在解锁时，我们需要判断当前解锁的竞争者id释放为锁持有者

第三个为 expx ，意思是要给这个key 加一个过期时间的设置

第四个参数为 time，与第四个参数相呼应，代表 key 的过期时间



setIfAbsent()方法就只会导致两种结果:

1. 当前没有锁，那么就直接进行加锁的操作，并对锁设置一个有效期
2. 已经有所存在，不做任何操作。缓存超时保证了及时一个竞争者加锁之后挂了，也不会产生死锁问题：超时后其他竞争者依然可以获取锁。通过设置 value 为竞争者的id



**解锁步骤：**

1. 判断当前解锁的竞争者id是否为 锁的持有者，如果不是直接返回失败，如果是进入第二步
2. 删除 key，如果删除成功，返回解锁成功，否则解锁失败





# 5、本地事务与分布式事务

在**Spring**里面并没有提供事务，它只是提供了对数据库事务管理的封装，通过声明式的事务配置，使得开发人员可以从一些复杂的事务处理中的到解脱，不再需要关心连接和获取，连接的关闭，事务提交，事务回滚这些操作，更加聚焦在业务开发层面，所以 Spring 里面的事务，本质上就是数据库层面的事务

**分布式**事务，是解决多个数据库的事务操作的数据一致性问题，传统的关系型数据库不支持跨库事务的操作，所以需要引入分布式事务的解决方案

而 Spring 并没有提供分布式事务场景的支持，所以 Spring 事务和分布式事务在使用上并没有直接的关联性



# 6、单例模式为什么需要两次检测锁

**简单来说的话：就是为了防止创建多个实例**

==第一次检测：==

由于单例模式只需要创建一次实例，如果后面再次调用 `getInstance` 方法时，则直接返回之前创建的实例，因此大部分时间不需要执行 同步方法里面的代码，大大提高了性能，如果不加第一次校验的话，每次都要去竞争锁。

==第二次检测：==

如果没有第二次校验，假设线程 t1 执行了第一次校验后，判断为 null，这是线程 t2 也获取了CPU执行权，去执行第一次校验，判断也是 null。接下来 t2 获得锁，创建了实例。这时 t1 又获得 CPU 执行权，由于之前已经进行第一次校验，结果未 null（不会再次判断），获得锁后直接创建实例。这样的话就会导致创建多个实例。所以需要在同步代码块里面进行第二次校验，如果实力为空，则进行创建。



# 7、MySQL主从复制

1、核心的实现是通过binlog来实现的，公司用的是一主多从的方式或者主主复制的模式
2、 主从都要开启binlog,当开启binlog之后，主库做的所有操作(dataChange) 都会记录到binlog中后台会有一个io thread来binlog中拉取数据，将日志文件放到从机的relaylog (中继日志)从机会有一个sq| thread来重relaylog中的记录，将修改的数据同步到从库中
3、 其实使用了顺序读写的特点，binlog, relaylog都是顺序读写的， 速度高于随机读写，当然在实际的工作场景中还回出现主从复制延迟的问题，我们采用了MTS的方式来解决，当多个并发线程写数据的时候，从机也会有多个并行的线程在同步数据，MTS实现的方式是组提交
4、 这是我对主从复制的理解，您看有什么问题，帮我指点一 下



















