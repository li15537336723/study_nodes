方向：类加载机制、GC算法，常见的垃圾回收机制，JVM调优



### Java 内存区域和 JMM 有何区别？

这是一个比较常见的问题，很多初学者非常容易搞混。 **Java 内存区域和内存模型是完全不一样的两个东西** ：

- JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。
- Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。

### Java内存区域

在jdk1.8之前

![img](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211141645727.png)

在JDK1.8之后

![img](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211141645321.png)

### 解释 JVM 堆空间及 GC？

分类两部分：

* 年轻代：
  * Eden：新创建的对象会存放到这
  * S0：Eden满之后，会触发一次MinorGC，会将存活的对象放到这
  * S1：当S0存满时，会触发一次MinorGC，将存活的对象移动到到这，此时发生一次位置交换，S1在一段时间内处于空
* 老年代：
  * 经过多次的Minor GC后，仍然存活的对象会移动到这

### 说一下 JVM 的主要组成部分及其作用？

* 类加载器：加载类文件到内存。Class loader只管加载，只要符合文件结构就加载，至于能否运行，它不负责，那是有Exectution Engine 负责的。

* 执行引擎：也叫解释器，负责解释命令，交由操作系统执行。

* 本地库接口：本地接口的作用是融合不同的语言为java所用

* 运行时的数据区：

  * 堆：堆是java对象的存储区域，任何用new字段分配的java对象实例和数组，都被分配在堆上，java堆可用-Xms和-Xmx进行内存控制，jdk1.7以后，运行时常量池从方法区移到了堆上。
  * 方法区（1.7：永久代，1.8：元空间）： 用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。

  * 虚拟机栈：虚拟机栈中执行每个方法的时候，都会创建一个栈桢用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
  * 本地方法栈：与虚拟机发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的Native方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
  * 程序计数器：指示Java虚拟机下一条需要执行的字节码指令。	

### 深拷贝和浅拷贝？

* 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。

* 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

### 浅拷贝和赋值的区别？

- 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
- 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。

### 说一下堆栈的区别？

* 栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。

* 堆内存存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。

### 什么是直接内存？

直接内存是Java堆外的、直接向系统申请的内存区间。

常用于大文件读写，Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。

缺点：分配回收成本高，不受JVM内存回收管理。

大小：可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值一Xmx参数值一致。

### 对象的创建过程？

1. 检查类是否已经被加载
2. 为对象分配内存空间
   * 指针碰撞：这种分配方式建立在内存是绝对规整的前提下，将堆内存区域分为两个部分，一部分是分配过内存的地方，一部分是未分配过内存的地方，使用指针指向的方式，将两块区域分别开来。分配内存时。
   * 空闲链表：这个方式解决内存堆空间不连续的情况，已使用和未使用的空间在一起相互交融。在分配内存的时候，找到一块足够大的内存交给对象，但是这种方式会造成内存空间的碎片化。
3. 为对象字段设置零值
4. 设置对象头
5. 执行构造方法

### 并发情况下对象安全性

* CAS 虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。
* 本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过-XX:+/- UseTLAB参数来设定虚拟机是否使用TLAB(JVM会默认开启-XX:+UseTLAB)，-XX:TLABSize 指定TLAB大小。

### 对象的访问定位

Java 类型分为基础数据类型（int 等）和引用类型（Reference），虽然两者都是数值，但却有本质的区别：基础数据类型本身就代表数据，而引用本身只是一个地址，并不代表对象数据。那么，虚拟机是如何通过引用定位到实际的对象数据呢？具体访问定位方式取决于虚拟机实现，目前有 2 种主流方式：

- **1、直接指针访问：** 引用内部持有一个指向对象数据的直接指针，通过该指针就可以直接访问到对象数据。采用这种方式的话，就需要在对象数据中额外使用一个指针来指向对象类型数据；
- **2、句柄访问：** 引用内部持有一个句柄，而句柄内部持有指向对象数据和类型数据的指针（句柄位于 Java 堆中句柄池）。使用这种方式的话，就不需要在对象数据中记录对象类型数据的指针。

使用句柄的优点是当对象在垃圾收集过程中移动存储区域时，虚拟机只需要改变句柄中的指针，而引用保持稳定。而使用直接指针的优点是只需要一次指针跳转就可以访问对象数据，访问速度相对更快。以 Sun HotSpot 虚拟机而言，采用的是直接指针方式，而 Android ART 虚拟机采用的是句柄方式。

[handle.h](https://link.juejin.cn?target=http%3A%2F%2Fandroidxref.com%2F9.0.0_r3%2Fxref%2Fart%2Fruntime%2Fhandle.h%23reference_)

```cpp
// Android ART 虚拟机源码体现：
// Handles are memory locations that contain GC roots. As the mirror::Object*s within a handle are
// GC visible then the GC may move the references within them, something that couldn't be done with
// a wrap pointer. Handles are generally allocated within HandleScopes. Handle is a super-class
// of MutableHandle and doesn't support assignment operations.
template<class T>
class Handle : public ValueObject {
	...
}
复制代码
```

**直接指针访问：**

![img](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211151023755.webp)

**句柄访问：**

![img](https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211151023791.webp)




### 怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？

获取属性：System.getProperty("sun.arch.data.model")；

### 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多少？

* 32位JVM的寻址空间只有2^32（4G），也就是说你的进程最大只能使用4G内存。并且由于还存在其他的一些限制，比如说swap空间、内核空间占用、内存碎片等等，实际上jvm可利用的内存要远小于4G。

  

* | OS       | Max Heap |
  | -------- | -------- |
  | Linux    | 2-3GB    |
  | AIX      | 3.25GB   |
  | Windows  | 1.5GB    |
  | Solaris  | 2~4GB    |
  | Mac OS X | 3.8GB    |

* 64位JVM，寻址空间最大是2^64，几乎就是无限大了。

### JRE、JDK、JVM 及 JIT 之间有什么不同？

* JVM：Java虚拟机，是JRE的一部分。它是整个java实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行java字节码文件的虚拟计算机。所有平台的上的JVM向编译器提供相同的接口，而编译器只需要面向虚拟机，生成虚拟机能识别的代码，然后由虚拟机来解释执行。
* JRE：JRE（Java Runtime Environment，Java运行环境），包含JVM标准实现及Java核心类库。 JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件
* JDK：Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（JRE），Java工具（javac/java/jdb等）和Java基础的类库（即Java API ）。
* JIT：当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”编译成本地机器相关的机器码，并进行优化，然后再把编译后的机器码缓存起来，以备下次使用。

### Java内存溢出异常，什么情况下会发生栈内存溢出？

在年轻代中经过GC后还存活的对象会被复制到老年代中。当老年代空间不足时，JVM会对老年代进行完全的垃圾回收（Full GC）。如果GC后，还是无法存放从Survivor区复制过来的对象，就会出现OOM（Out of Memory）。

OOM（Out of Memory）异常常见有以下几个原因：
1）老年代内存不足：java.lang.OutOfMemoryError:Javaheapspace
2）永久代内存不足：java.lang.OutOfMemoryError:PermGenspace
3）代码bug，占用内存无法及时回收。
OOM在这几个内存区都有可能出现，实际遇到OOM时，能根据异常信息定位到哪个区的内存溢出。
可以通过添加个参数-XX:+HeapDumpOnOutMemoryError，让[虚拟机](https://www.zhihu.com/search?q=虚拟机&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"43062139"})在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后分析。

熟悉了JAVA内存管理机制及配置参数，下面是对JAVA应用启动选项调优配置：

```text
JAVA_OPTS="-server -Xms512m -Xmx2g -Xmn1g -XX:PermSize=256m -XX:MaxPermSize=512m -XX:+UseConcMarkSweepGC -XX:+UseParallelGCThreads=8 XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:-PrintGC -XX:-PrintGCDetails -XX:-PrintGCTimeStamps -Xloggc:../logs/gc.log"
```

- 设置堆内存最小和最大值，最大值参考历史利用率设置
- 设置GC垃圾收集器为CMS或者G1
- 启用GC日志，方便后期分析

### Java会存在内存泄漏吗？请简单描述？

内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。

内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

memory leak会最终会导致out of memory

有以下几种情况会发生内存泄露：

* 静态字段保持对象引用
* 在长字符串上调用String.intern（）
* 忘记关闭Stream，在Java 7中，当自动关闭所有类型的Stream的功能被置入到 [try-with-resource clause](https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html)中时，已不会出现。
* 未关闭的连接，例如数据库，FTP服务器等
* 将没有hashCode（）和equals（）的对象添加到HashSet中



### 简述Java垃圾回收机制

在Java开发中，程序员并不需要显式去释放一个对象的内存的，而是由虚拟机自动进行管理。在JVM中，有一个低优先级的垃圾回收线程，在正常情况下这个线程是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的对象集合中，然后进行回收操作。

垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：

\- 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。

\- 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。

\- 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。

[Java垃圾回收机制 - Matrix海子 - 博客园 (cnblogs.com)](https://www.cnblogs.com/dolphin0520/p/3783345.html)

### GC是什么？为什么要GC?

GC是垃圾收集的意思，[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)处理是开发人员容易出现问题的地方，忘记或者错误地内存回收会导致程序或者系统的不稳定甚至崩溃，Java提供的垃圾回收机制可以自动检测对象是否超过作用域从而达到自动回收的目的。



### 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。

可以。

程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。强制执行垃圾回收：System.gc()。Runtime.getRuntime().gc()


### 你能保证 GC 执行吗？

不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC的执行。

### Java 中都有哪些引用类型？

强引用、软引用、弱引用、虚引用

* 在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被[垃圾回收](https://so.csdn.net/so/search?q=垃圾回收&spm=1001.2101.3001.7020)机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。
* 软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。
* 弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 [JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020) 的内存空间是否足够，总会回收该对象占用的内存。
* 虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。

### 介绍一下强引用、软引用、弱引用、虚引用的区别？

* 强引用：
  * 直接访问目标对象
  * 不会被回收
  * 可能导致内存泄露
* 软引用：
  * 内存充足，不会回收
  * 内存到达阀值，回收
* 弱引用：
  * 具有很短的声明周期
  * 无论内存是否足够，GC发现就会释放
  * GC线程优先级低，不一定及时发现
* 虚引用：
  * 不影响对象生命周期
  * 任何时候都可能回收
  * 用来跟踪回收对象，清理相关资源

### 在Java中，对象什么时候可以被垃圾回收

判断一个对象是否存活有两种方法：引用计数法和可达性分析法

* 引用计数法：
  * 所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加1，引用失效时，计数器就减1。当一个对象的引用计数器为0时，说明此对象没有被其他对象引用，也就是死对象，将会被GC回收。
        缺陷：无法解决循环引用问题，也就是说对象A引用对象B，对象B反过来引用对象A，那么此时A、B对象的引用计数器都不为0，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
* 可达性分析法：
  *  从一个被称为GC Roots的对象开始往下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。
        可以作为GC Roots的对象有以下几种：
    * 虚拟机栈中引用的对象
    * 方法区类静态属性引用的对象
    *  方法区常量池引用的对象
    * 方法栈JNI引用的对象

当一个对象不可达GC Roots时，这个对象并不会立马被回收，而是处于一个死缓的阶段，如果要真正的回收需要经历两次标记。如果对象在可达性分析中没有与GC Roots的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没有必要的。如果该对象有必要执行finalize()方法，那么这个对象就会放在一个称为F-Queue的队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()方法执行缓慢或者发生了死锁，那么就是造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于 F-Queue队列中的对象进行第二次标记，这时，该对象将会被移出“即将回收”集合，等待回收。

### 为什么堆要分新生代和老年代呢？

假设一下，如果不分新老代，内存就一整块，垃圾收集器每次都要把那些长期存在的对象，和生命周期很短的对象放在一起回收，一般长生命周期的对象可能跟应用生命周期一致，你基本回收不掉的，比如Spring 框架里面的Bean管理相关的对象（ApplicationContext），整个应用运行期间都存在，这种一般经过几次回收最后都放在老年代，但是如果不区分新老代，每次都一起回收，性能消耗很大。

区分新老代之后，老年代放长期存活的对象，新生代就放生命周期短的对象，老年代对象很稳定，新生代回收不影响老年代，回收效率能大大提高。

### 新生代为什么不用垃圾清除或者垃圾整理算法

若是在新生代使用垃圾清除或者垃圾整理算法，显然不需要对新生代进行分区。

若是采用标记清除算法：会在新生代产生内存碎片，但是新生代是Java 新对象的出生地，内存碎片化显然是我们不想看到的；

若是采用标记整理算法：虽然标记整理可以解决内存碎片化问题，但是考虑到新生代98%的对象都是“朝生夕死”的，对象被回收掉后会产生很多内存碎片，我们移动存活对象的时候需要耗费大量的时间，远不如直接把这2%对象放到另一个地方采用复制算法更加高效。

### 为什么新生代还要分Eden、From、To区域呢？

前面的分析我们已经得出结论：新生代采用复制算法更加高效。

如果没有Survivor区（From + To），Minor GC（新生代回收）过程中，存活的对象直接被送到老年代，这样的话老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC），Full GC频繁会影响程序的执行和响应速度。

### 为什么要设置两个Survivor区呢？From 和 To

前面的分析我们已经得出结论：新生代采用复制算法更加高效，且需要对新生代进行分区。

主要还是效率问题，假设将新生代分为Eden和Survivor两个区域，显然对Eden区采用复制算法，对Survivor区采用标记整理算法，这样又回到在新生代使用复制算法效率比标记整理效率高的分析。所以需要通过将Survivor区分为From 和 To区解决。

### JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代

Java堆 = 老年代 + 新生代 | 大小比例为1:2，如下
新生代 = Eden + S0 + S1 也称 form和 to

当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor 区。具体参考我的另外一篇：点这里：深入讲解JVM垃圾回收算法思想及全过程）

大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年代；
如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，熬过了一轮又一轮，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年代。
Minor GC 是清理新生代
Full GC老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和老年代。
Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。
Minor GC触发机制：
当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。
Full GC触发机制：
（1）调用System.gc时，系统建议执行Full GC，但是不必然执行
（2）老年代空间不足
（3）方法区空间不足
（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
（5）由Eden区、survivor space1（From Space）区向survivor space2（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载

### JVM中的永久代中会发生垃圾回收吗

而1.7以前的jdk采用的是永久代作为方法区的实现，在1.7及以前的jdk版本，永久代的空间不足也会导致fullGC，
1.7以前，永久代空间如果设小了，就会触发整个堆的一次full
GC（注意是触发堆的full GC），经过这样的一次定位就初步定位到了是由于永久代空间不足导致了堆的full GC

1.8以后由于改成了元空间，它的垃圾回收就不是由java来控制了，元空间的默认情况下内存空间是使用的操作系统的内存空间，所以空间的容量是比较充裕的，不会发生元空间的空间不足问题。

### 元空间大小？

因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由 MaxPermSize控制, 而由系统的实际可用空间来控制。

### 说一下 JVM 有哪些垃圾回收算法？

* 标记-清除算法：
  * 该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。
  * 这种垃圾收集算法会带来两个明显的问题：
    1. 效率问题
    2. 空间问题（标记清除后会产生大量不连续的碎片）
* 标记-复制算法：
  * 为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。
  * 问题：
    * 内存空间利用率低
* 标记-整理算法：
  * 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
* 分代收集算法：
  * 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
  * 比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。