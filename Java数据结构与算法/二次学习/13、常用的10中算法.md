# 十种常用的算法

## 一、二分叉找算法（非递归）

1）二分查找法只适用于从有序的数列中进行查找（比如数字和字母等），将数列排序后在进行查找

2）二分查找算法的运行时间为对数时间<img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/image-20211104214059840.png" alt="image-20211104214059840" style="zoom: 67%;" />，即查找到需要的目标位置最多只需要**log以2为底n的对数**步，假设从[0 ,99] 的队列（100个数，即 n = 100）中寻到目标数为 30 ，则需要查找步数为 <img src="https://lixianghong.oss-cn-beijing.aliyuncs.com/image-20211104214306119.png" alt="image-20211104214306119" style="zoom:67%;" />，即最多需要查找6次



#### 代码实现

```java
public static void main(String[] args) {
   int[] arr = {1,3,8,10,11,67,100};
   int index = binarySearch(arr, 1000);
  System.out.println("index = "+index);
}

public static int binarySearch(int[] arr, int target){
  int left = 0;
  int right = arr.length - 1;
  while (left <= right) {
    int mid = (left + right) / 2;
    if(arr[mid] == target){
      return mid;
    } else if (arr[mid] > target) {
      right = mid - 1;      // 向左查找
    }else{
      left = mid + 1;
    }
  }
  return -1;
}
```



## 二、分治算法

1）分治法是一种很重要的算法。字面上的解释是”分而治之“，就是把一个复杂的问题分成2个或更多的相同或相似的子问题，再把子问题分层更小的子问题.......直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（**快速排序，归并排序**）傅里叶变换

2）分治算法可以 **求解的问题**

- 二分搜索
- 大整数乘法
- 棋盘覆盖
- 合并排序
- 快速排序
- 线性时间选择
- 最接近点对问题
- 循环赛日程表
- 汉诺塔

### 分治算法的基本步骤

分解：将原问题分解为诺干个规模较小，相互独立，与原问题形式相同的子问题

解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题



### 汉诺塔游戏实现思路

1）如果是有一个盘，A --> C

如果我们有 n>=2 情况，我们总是可以看作是两个盘，1. 最下面的一个盘。2. 上面的所有盘

1）先把最上面的盘 A --> B

2）最下边的盘 A --> C

3）把 B 塔的所有盘从 B --> C



#### 代码实现

```java
public static void main(String[] args) {
  han(2, 'A', 'B', 'C');
}
public static void han(int n, char a, char b, char c){
  if(n == 1){
    System.out.println("第1个盘从 " + a + " 移动到了 " + c);
  } else {
    // 先将最上面的盘移动到 B
    han(n - 1, a, c, b);
    // 将最下面的盘移动到 C
    System.out.println("第"+n+"个盘从 " + a + " 移动到了 " + c);
    // 将 B 上的盘移动到 C
    han(n - 1, b, a, c);
  }
}
```



## 三、动态规划算法

### 应用场景-背包问题

背包问题：有一个背包，容量为 4 磅，现有如下

![image-20211105212830749](https://lixianghong.oss-cn-beijing.aliyuncs.com/image-20211105212830749.png)

1）要求达到的目标为装入的背包的总价值最大，并且重量不超出

2）要求装入的物品不能重复



### 动态规划算法介绍

1）动态规划算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

2）动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

3）与分治法不同是，**适合于动态规划求解的问题，经分解得到子问题往往不是互相独立的。**（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）

4）动态规划可以通过 **填表的方式** 来逐步推进，得到最优解。



### 动态规划算法最佳实践-背包问题

#### 思路分析

背包问题主要是指一个给定容量的背包，若干具有一定价值的重量的物品，如何选择物品放入背包使物品的价值最大。其中又分 01 背包和完全背包（完全背包指的是：每种物品都有无限件可用）

这里的问题属于 01 背包，即每个物品最多放一个。而无限背包可以转化为 01 背包



算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w[i] 和 v[i] 来确定是否需要将该物品放入背包中。即对于给定的 n 个物品，设 v[i]、w[i] 分别为第 i 个物品的价值和重量，C为背包的容量。再令 v\[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包的最大价值。则我们有下面的结果：

（1）v\[i][0]  = v\[0][j];	//表示填入表第一行和第一列是 0

（2）当 w[i] > j 时：v\[i][j] 	// 当准备加入新增的商品容量大于当前背包的容量时，就直接使用上一个单元格的装入策略

（3）当 j>=w[i] 时：`v[i][j] = max{v[i - 1][j], v[i] + v[i-1][j-w[i]]}` 

//当准备加入的新增的商品的容量小于等于当前背包的容量

//装入的方式

v\[i - 1][j]：就是上一个单元格的装入的最大值

v[i]：表示当前商品的价值

 `v[i - 1][j - w[i]]` ：装入 i - 1 商品，到剩余空间 `j - w[i]` 的最大值

当 j >= w[i] 时：`v[i][j] = max{v[i-1][j],v[i]+v[i-1][j-w[i]]}`



















































































