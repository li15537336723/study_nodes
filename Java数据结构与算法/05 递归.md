### 递归的概念

简单的说：递归就是方法自己调用自己，每次调用时传如不同的变量。递归有助于编程者解决复杂的问题，同时可以让代码变得简洁



### 递归需要遵守的重要规则

1. 执行一个方法时,就创建一个新的受保护的独立空间(栈空间)
2. 方法的局部变量是独立的,不会互相影响,比如 n 变量
3. 如果方法中使用的是引用类型变量(比如数组),就会共享该引用类型的数据
4. 递归必须向退出递归的条件逼近,否则就是无限递归
5. 当一个方法执行完毕,或者遇到 return ,就会返回,遵守谁调用,就将结果返回给谁,同时当方法执行完毕或者返回时,该方法也就执行完毕



## 递归——迷宫问题

![image-20210314203807830](C:\Users\李祥鸿\AppData\Roaming\Typora\typora-user-images\image-20210314203807830.png)

**红色部分表示墙，红的圈要求从左上角到右下角**

```java
public static void main(String[] args) {
    // 定义一个二维数组用来表示地图
    int map[][] = new int[8][7];

    for(int i = 0 ; i < 7; i++) {
        map[0][i] = 1;
        map[7][i] = 1;
    }
    for(int i = 0 ; i < 8; i++) {
        map[i][0] = 1;
        map[i][6] = 1;
    }
    // 设置挡板
    map[3][1] = 1;
    map[3][2] = 1;
    System.out.println("地图的情况");
    for(int i = 0 ; i < 8; i++) {
        for(int j = 0; j < 7; j++) {
            System.out.print(map[i][j]+ " ");
        }
        System.out.println();
    }


    // 使用递归回溯给小球找路
    setWay(map, 1, 1);

    // 输出新的地图，小球走过的地图
    System.out.println("走过之后地图的情况");
    for(int i = 0 ; i < 8; i++) {
        for(int j = 0; j < 7; j++) {
            System.out.print(map[i][j]+ " ");
        }
        System.out.println();
    }
}

	/*
	 * 使用递归回溯来给小球找路
	 * 说明：
	 * 1. map 表示地图
	 * 2. i, j 表示从地图地哪个位置开始出发(1,1)
	 * 3. 如果小球能找到 map[6][5], 则说明通路找到
	 * 4. 约定：当 map[i][j] 为 0 表示该点没有 走过，当为 1 表示墙，2 表示通路可以走，3 表示该点已经走过，但是走不通
	 * 5. 在走迷宫时需要确定一下策略（方法）下->右->上->-左， 如果该点走不通，再回溯 
	 */

	/**
	 * 
	 * @param map	表示地图
	 * @param i，j	表示地图地 那个位置开始出发(1,1)		
	 * @param 
	 *  @return	如果找到通路，就返回 true，否则返回法拉瑟
	 */
public static boolean setWay(int[][] map, int i, int j) {
    if(map[6][5] == 2) {	// 表示已经找到了通路
        return true;
    }else {
        if(map[i][j] == 0) {	// 如果当前这个点还没走过
            // 按照策略 下 右 上 左
            map[i][j] = 2;	// 假定该点是可以走通
            if(setWay(map, i+1, j)) { //  向下走
                return true;
            }else if(setWay(map, i, j+1)){ // 向右走
                return true;
            }else if(setWay(map, i-1, j)) { // 向上走
                return true;
            }else if(setWay(map, i, j-1)) { // 向左走
                return true;
            }else {
                // 说明该点是走不通地
                map[i][j] = 3;
                return false;
            }
        }else {	// 如果通过的 map[i][j] != 0, 可能是 1  2  3
            return false;
        }
    }
}
```



### 八皇后问题

思路：

1）第一个皇后先放第一行第一列

2）第二个皇后放在第二行第一列，然后判断是否OK，如果不OK，继续放在第二列，第三列，一次把所有列都放完，找到一个合适

3）继续第三个皇后，还是第一列，第二列，，，知道第八个皇后也能放在一个冲突的位置，算是找到了一个正确解

4）当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到

5）然后回头继续第一个皇后放到第二列，后面继续循环执行1，2，3，4 步骤



说明：

理论上应该创建一个二维数组来表示期盼，但实际上可以通过算法，用一维数组即可解决问题arr[8] = {0,4,7,5,2,6,1,3} 对应arr下表，表示第几行，即第几个皇后，arr[i] = val,val 表示第 i+1个皇后，放在第 i+1行的第 val+1 列



















































































